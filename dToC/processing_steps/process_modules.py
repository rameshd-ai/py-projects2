import json
import os
import re 
from typing import Dict, Any, List, Union

# IMPORTANT: These must be correctly defined in 'apis' and 'config'
# Assuming these imports are available in your environment
from apis import GetPageCategoryList 
from config import UPLOAD_FOLDER 

# --- UTILITY FUNCTION FOR FUZZY MATCHING ---
def normalize_page_name(name: str) -> str:
    """
    Normalizes a page or category name for robust comparison.
    Converts to lowercase, strips whitespace, and removes all non-alphanumeric characters.
    """
    if not name:
        return ""
    normalized = name.strip().lower()
    normalized = re.sub(r'[^a-z0-9]', '', normalized)
    return normalized

def get_config_filepath(file_prefix: str) -> str:
    """
    Constructs the unique config.json filepath based on the prefix.
    It relies on the 'file_prefix' being the unique ID + the original filename slug.
    We ensure the unique ID is extracted if a full path is mistakenly passed.
    """
    base_prefix = os.path.basename(file_prefix)
    config_filename = f"{base_prefix}_config.json"
    return os.path.join(UPLOAD_FOLDER, config_filename)

def load_settings(file_prefix: str) -> Dict[str, Any] | None:
    """Loads the settings/config file based on the unique prefix."""
    # Note: get_config_filepath handles the path/basename extraction for us
    filepath = get_config_filepath(file_prefix) 
    if not os.path.exists(filepath):
        print(f"Module Processor: Config file not found at {filepath}")
        return None
    try:
        with open(filepath, "r") as f:
            return json.load(f)
    except Exception as e:
        print(f"Module Processor: Error loading config file: {e}")
        return None

# --- UTILITY FUNCTION TO DYNAMICALLY FIND THE PROCESSED JSON FILE (KEY FIX HERE) ---
def find_processed_json_filepath(file_prefix: str) -> str | None:
    """
    Dynamically finds the processed JSON file based on the unique prefix, 
    even if the prefix argument contains path information.
    """
    # FIX: Use os.path.basename to reliably isolate the unique ID component
    base_prefix = os.path.basename(file_prefix)

    # print(f"Module Processor: Searching UPLOAD_FOLDER ('{UPLOAD_FOLDER}') for file starting with '{base_prefix}' and ending with '_simplified.json'.")
    
    if not os.path.isdir(UPLOAD_FOLDER):
        print(f"FATAL ERROR: UPLOAD_FOLDER path does not exist or is not a directory: {UPLOAD_FOLDER}")
        return None
        
    for filename in os.listdir(UPLOAD_FOLDER):
        # Use the isolated base_prefix for matching
        if filename.startswith(base_prefix) and filename.endswith("_simplified.json"):
            filepath = os.path.join(UPLOAD_FOLDER, filename)
            # print(f"Module Processor: âœ… Match found: {filename}")
            return filepath
            
    # print(f"Module Processor: âŒ No processed JSON file found matching the criteria for prefix '{base_prefix}'.")
    return None

# --- UTILITY FUNCTION TO SAVE PROCESSED JSON (Uses dynamic path) ---
def save_processed_json(file_prefix: str, data: Dict[str, Any]) -> bool:
    """Saves the processed JSON data back to its dynamically located file."""
    # find_processed_json_filepath now handles the robust prefix extraction
    filepath = find_processed_json_filepath(file_prefix)
    
    if not filepath:
        print(f"Module Processor: Error saving. Could not find target processed JSON file starting with '{os.path.basename(file_prefix)}'. Cannot save.")
        return False

    try:
        with open(filepath, "w") as f:
            json.dump(data, f, indent=4)
        # print(f"âœ… Successfully saved updated processed JSON to {filepath}")
        return True
    except Exception as e:
        print(f"Module Processor: Error saving processed JSON file: {e}")
        return False

# --- PLACEHOLDER FUNCTION FOR CATEGORY CREATION ---
def createCategory(page_name: str, site_id: str):
    """Placeholder function to simulate calling the API to create a new category."""
    print(f"\nâš™ï¸ Calling createCategory for Page Name: '{page_name}' (Site ID: {site_id})...")
    print("TODO: Implement API call to /api/PageApi/CreateCategory in the next step.")


# --- MODIFIED FUNCTION: Load the JSON result from the XML processing step ---
def load_processed_json(file_prefix: str) -> Dict[str, Any] | None:
    """
    Loads the JSON file generated by the process_xml step.
    If the file is not found, it returns None.
    """
    # 1. Dynamically find the file
    filepath = find_processed_json_filepath(file_prefix)
    
    # 2. Check if the file exists. If not, return None immediately.
    if not filepath or not os.path.exists(filepath):
        return None

    # 3. Load the actual file
    try:
        print(f"Module Processor: Loading actual processed JSON from: {filepath}")
        with open(filepath, "r") as f:
            return json.load(f)
    except Exception as e:
        print(f"Module Processor: Error loading processed JSON file at {filepath}: {e}")
        return None

    
def run_module_processing_step(
    input_filepath: str, 
    step_config: Dict[str, Any], 
    previous_step_data: Dict[str, Any]
) -> Dict[str, Any]:
    """
    The main execution function for the module processing step.
    """
    # 1. Get the unique file prefix from the previous step's data
    file_prefix = previous_step_data.get('file_prefix')
    if not file_prefix:
        raise ValueError("Module Processing failed: Missing unique file prefix.")

    # 2. Load settings to get the target URL, Site ID, and token
    settings = load_settings(file_prefix)
    if not settings:
        raise RuntimeError("Could not load user configuration. Aborting module processing.")

    target_url = settings.get("target_site_url")
    site_id = settings.get("site_id")
    
    # --- FIX START: Correctly retrieve the raw token string ---
    # The user-provided config uses 'cms_login_token' for the raw string.
    raw_token = settings.get("cms_login_token") 
    
    if not target_url or not raw_token or not site_id:
        # Updated error message to reflect the correct key
        raise ValueError("Error: Target URL, Site ID, or **CMS Login Token** missing in configuration. Cannot fetch modules.")
    
    # Validation: Ensure the token is a non-empty string as expected from the config file.
    if not isinstance(raw_token, str) or not raw_token.strip():
        raise TypeError(f"Expected 'cms_login_token' to be a non-empty string, but received {type(raw_token)}.")

    # --- FIX END ---
    
    # 4. Construct the required headers
    headers = {
        'Content-Type': 'application/json',
        'ms_cms_clientapp': 'ProgrammingApp',
        # Use the raw_token string directly
        'Authorization': f'Bearer {raw_token}',
    }
    
    # --- Logic: Load and extract ALL target page names ---
    processed_json = load_processed_json(file_prefix)
    
    # If the JSON file is missing after XML processing (an upstream error)
    if processed_json is None:
        # NOTE: The load_processed_json function is now using os.path.basename, so this error should only
        # trigger if the file simply doesn't exist, meaning the previous step failed to save it.
        raise RuntimeError(f"Processing failed: Could not load the required '_simplified.json' file for prefix '{os.path.basename(file_prefix)}'. Check the previous XML processing step.")

    level1_page_names: List[str] = [] 
    
    if 'pages' in processed_json and isinstance(processed_json['pages'], list):
        for page in processed_json['pages']:
            if 'page_name' in page:
                level1_page_names.append(page['page_name'])
        
        # print(f"\nâœ… Extracted {len(level1_page_names)} Level 1 Page Name(s) from processed JSON: {level1_page_names}")
    else:
        # print("âš ï¸ Processed JSON structure is missing the 'pages' list. Aborting category check.")
        return {
            "modules_fetched_count": 0,
            "file_prefix": file_prefix
        }
            
    if not processed_json['pages']:
        print("Skipping category check as no Level 1 Page was found to process.")
        return {
            "modules_fetched_count": 0,
            "file_prefix": file_prefix
        }

    # print(f"Module Processor: Attempting to fetch modules from {target_url}...")
    
    # 5. Call the API to get the category list
    api_result: Union[List[Dict[str, Any]], Dict[str, Any]] = GetPageCategoryList(target_url, headers)
    
    # --- CRITICAL: Robust Error Handling for API Result ---
    if not isinstance(api_result, list):
        # If it's not a list, we assume it's the error dictionary (or corrupted data)
        if isinstance(api_result, dict) and 'error' in api_result:
            error_type = api_result.get('error', 'Unknown Error')
            details = api_result.get('details', 'No details provided.')
            status_code = api_result.get('status_code', 'N/A')
            
            raise RuntimeError(f"API Call to GetPageCategoryList Failed (Status: {status_code}). Error: {error_type}. Details: {details}")
        else:
            # Handle the case where the data is not a list OR an expected error dictionary
            raise RuntimeError(f"API returned an unexpected data type ({type(api_result)}). Expected List or Error Dict.")

    module_list = api_result
    # print(f"Module Processor: Successfully retrieved {len(module_list)} modules.")
    
    # 6. Logic: Search for ALL page names in the retrieved modules and map the results
    # print("\n--- Category Matching and ID Retrieval Process ---")
    
    # Create a dictionary for efficient fuzzy lookup: normalized_name -> category_object (with ID)
    normalized_category_map: Dict[str, Dict[str, Any]] = {}
    for module in module_list:
        category_name = module.get('CategoryName')
        category_id = module.get('CategoryId')
        if category_name and category_id is not None:
            normalized_name = normalize_page_name(category_name)
            normalized_category_map[normalized_name] = {
                'CategoryId': category_id,
                'CategoryName': category_name
            }

    pages_updated = 0
    
    # Iterate directly over the page objects in the processed_json so we can modify them
    for page in processed_json['pages']:
        page_name = page.get('page_name')
        if not page_name:
            continue

        normalized_page_name = normalize_page_name(page_name)
        
        # print(f"\nðŸ” Checking Page Name: '{page_name}' (Normalized: '{normalized_page_name}')")

        # Look up category info using the normalized name
        category_info = normalized_category_map.get(normalized_page_name)

        if category_info:
            # MATCH FOUND: Extract ID and update the page object
            category_id = category_info['CategoryId']
            category_name_api = category_info['CategoryName']

            # CRITICAL: This updates the page object in the main processed_json dict
            page['category_info'] = {
                'CategoryId': category_id,
                'CategoryName': category_name_api,
                'match_type': 'fuzzy_name_match'
            }
            pages_updated += 1
            
            # print("âœ… match found") 
            # print(f"âœ… FOUND: Page '{page_name}' matches Category ID {category_id} ('{category_name_api}'). Category ID attached to page object.")
        else:
            # print(f"âŒ NOT FOUND: Page '{page_name}' does not match an existing Category.")
            # Call the creation function if no match is found
            createCategory(page_name, site_id)
        
    # 7. Final step: Save the updated JSON data back to disk
    if pages_updated > 0 and processed_json:
        # print("\nSaving updated JSON structure...")
        save_processed_json(file_prefix, processed_json)
    elif processed_json:
        print("No new category information was added to the processed JSON, skipping save.")

    print(f"\n--- API Fetch Results ---")
    print(f"Total items fetched: {len(module_list)}")
    print("--------------------------\n")
    
    return {
        "modules_fetched_count": len(module_list),
        "pages_checked_count": len(level1_page_names),
        "pages_updated_with_category_id": pages_updated,
        "file_prefix": file_prefix # Continue propagating the prefix
    }