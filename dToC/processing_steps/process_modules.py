import json
import os
from typing import Dict, Any, List, Union

# Import the API function
from apis import GetPageCategoryList
from config import UPLOAD_FOLDER

# --- Define the static part of the processed filename as a constant ---
PROCESSED_FILENAME_SUFFIX = "_394279_nationwide_hotel_conference_center_3.0_4_simplified.json"

def get_config_filepath(file_prefix: str) -> str:
    """Constructs the unique config.json filepath based on the prefix."""
    config_filename = f"{file_prefix}_config.json"
    return os.path.join(UPLOAD_FOLDER, config_filename)

def load_settings(file_prefix: str) -> Dict[str, Any] | None:
    """Loads the settings/config file based on the unique prefix."""
    filepath = get_config_filepath(file_prefix)
    if not os.path.exists(filepath):
        print(f"Module Processor: Config file not found at {filepath}")
        return None
    try:
        with open(filepath, "r") as f:
            return json.load(f)
    except Exception as e:
        print(f"Module Processor: Error loading config file: {e}")
        return None

# --- NEW FUNCTION: Placeholder for creating a category ---
def createCategory(page_name: str, site_id: str):
    """Placeholder function to simulate calling the API to create a new category."""
    print(f"\n‚öôÔ∏è Calling createCategory for Page Name: '{page_name}' (Site ID: {site_id})...")
    # Placeholder print statement as requested
    print("TODO: Implement API call to /api/PageApi/CreateCategory in the next step.")


# --- MODIFIED FUNCTION: Load the JSON result from the XML processing step ---
def load_processed_json(file_prefix: str) -> Dict[str, Any] | None:
    """
    Loads the JSON file generated by the process_xml step, using the new 
    specific filename format: {file_prefix}{SUFFIX}.
    
    If the file is not found, it creates a mock file for testing the comparison logic,
    which now includes multiple pages for testing iteration.
    """
    # 1. Construct the full, expected filepath
    processed_filename = f"{file_prefix}{PROCESSED_FILENAME_SUFFIX}"
    filepath = os.path.join(UPLOAD_FOLDER, processed_filename)
    
    # 2. Check if the file exists
    if not os.path.exists(filepath):
        print(f"Module Processor: Processed JSON file not found at {filepath}")
        print("‚ö†Ô∏è CREATING MOCK DATA for testing category search logic (using the required file name structure).")
        
        # --- MOCK DATA CREATION (Temporary for testing) ---
        # Mock data now contains two Level 1 pages: one that will match, one that won't
        mock_data = {
            "title": "394279 Nationwide Hotel & Conference Center",
            "pages": [
                {
                    "page_name": "Our Property",  # EXPECTED TO MATCH
                    "components": [],
                    "meta_info": {},
                    "sub_pages": []
                },
                {
                    "page_name": "Guest Rooms",  # EXPECTED TO NOT MATCH -> call createCategory
                    "components": [],
                    "meta_info": {},
                    "sub_pages": []
                }
            ]
        }
        
        try:
            with open(filepath, "w") as f:
                json.dump(mock_data, f, indent=4)
            print(f"‚úÖ Mock processed JSON created successfully at {filepath}. Continuing with mock data.")
            return mock_data 
        except Exception as e:
            print(f"Module Processor: Error creating mock JSON file: {e}")
            return None
        # --- END MOCK DATA CREATION ---

    # 3. Load the actual file
    try:
        with open(filepath, "r") as f:
            return json.load(f)
    except Exception as e:
        print(f"Module Processor: Error loading processed JSON file: {e}")
        return None

    
def run_module_processing_step(
    input_filepath: str, 
    step_config: Dict[str, Any], 
    previous_step_data: Dict[str, Any]
) -> Dict[str, Any]:
    """
    The main execution function for the module processing step.
    Loads user config (including the generated token) and calls the API to fetch modules.
    Then, it compares ALL main page names from the processed JSON against the fetched categories.
    """
    # 1. Get the unique file prefix from the previous step's data
    file_prefix = previous_step_data.get('file_prefix')
    if not file_prefix:
        raise ValueError("Module Processing failed: Missing unique file prefix.")

    # 2. Load settings to get the target URL, Site ID, and token
    settings = load_settings(file_prefix)
    if not settings:
        raise RuntimeError("Could not load user configuration. Aborting module processing.")

    target_url = settings.get("target_site_url")
    site_id = settings.get("site_id")
    auth_token_payload = settings.get("destination_token") 
    
    if not target_url or not auth_token_payload or not site_id:
        raise ValueError("Error: Target URL, Site ID, or Login Token missing in configuration. Cannot fetch modules.")
    
    # --- Logic: Load and extract ALL target page names ---
    processed_json = load_processed_json(file_prefix)
    level1_page_names: List[str] = []
    
    if processed_json and 'pages' in processed_json and isinstance(processed_json['pages'], list):
        for page in processed_json['pages']:
            if 'page_name' in page:
                level1_page_names.append(page['page_name'])
        
        print(f"\n‚úÖ Extracted {len(level1_page_names)} Level 1 Page Name(s) from processed JSON: {level1_page_names}")
    else:
        print("‚ö†Ô∏è Could not extract Level 1 Page Names. Check processed JSON structure.")
            
    if not level1_page_names:
        print("Skipping category check as no Level 1 Page Name was successfully extracted.")
        return {
            "modules_fetched_count": 0,
            "file_prefix": file_prefix
        }

    # 3. Extract the raw token value.
    if not isinstance(auth_token_payload, dict):
        raise TypeError(f"Expected 'destination_token' to be a dictionary, but received {type(auth_token_payload)}.")

    raw_token = auth_token_payload.get('token')

    if not raw_token:
         raise ValueError("Token value 'token' not found in authentication payload.")

    # 4. Construct the required headers
    headers = {
        'Content-Type': 'application/json',
        'ms_cms_clientapp': 'ProgrammingApp',
        'Authorization': f'Bearer {raw_token}',
    }

    print(f"Module Processor: Attempting to fetch modules from {target_url}...")
    
    # 5. Call the API to get the category list
    api_result: Union[List[Dict[str, Any]], Dict[str, Any]] = GetPageCategoryList(target_url, headers)
    
    # --- Error Handling ---
    if isinstance(api_result, dict) and 'error' in api_result:
        error_type = api_result.get('error', 'Unknown Error')
        details = api_result.get('details', 'No details provided.')
        status_code = api_result.get('status_code', 'N/A')
        
        raise RuntimeError(f"API Call Failed ({error_type}, Status: {status_code}). Details: {details}")
    
    module_list = api_result
        
    if not isinstance(module_list, list):
         raise RuntimeError(f"API returned data, but it was not the expected list structure. Type received: {type(module_list)}")

    print(f"Module Processor: Successfully retrieved {len(module_list)} modules.")
    
    # 6. Logic: Search for ALL page names in the retrieved modules
    print("\n--- Category Matching Process ---")
    
    # Create a set of normalized CategoryNames for efficient lookup
    normalized_category_set = set()
    for module in module_list:
        category_name = module.get('CategoryName')
        if category_name:
            normalized_category_set.add(category_name.strip().lower())

    for page_name in level1_page_names:
        normalized_page_name = page_name.strip().lower()
        
        print(f"\nüîç Checking Page Name: '{page_name}'...")

        if normalized_page_name in normalized_category_set:
            print("‚úÖ match found") 
            print(f"‚úÖ FOUND: Page '{page_name}' matches an existing Category.")
        else:
            print(f"‚ùå NOT FOUND: Page '{page_name}' does not match an existing Category.")
            # Call the creation function if no match is found
            createCategory(page_name, site_id)
        
    # 7. Final step logs and returns
    print(f"\n--- API Fetch Results ---")
    print(f"Total items fetched: {len(module_list)}")
    print("--------------------------\n")
    
    return {
        "modules_fetched_count": len(module_list),
        "pages_checked_count": len(level1_page_names),
        "file_prefix": file_prefix # Continue propagating the prefix
    }