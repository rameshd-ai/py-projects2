import json
import os
import re 
from typing import Dict, Any, List, Union

# Import the API function
from apis import GetPageCategoryList
from config import UPLOAD_FOLDER

# --- Define the static part of the processed filename as a constant ---
PROCESSED_FILENAME_SUFFIX = "_394279_nationwide_hotel_conference_center_3.0_4_simplified.json"

# --- NEW UTILITY FUNCTION FOR FUZZY MATCHING ---
def normalize_page_name(name: str) -> str:
    """
    Normalizes a page or category name for robust comparison.
    Converts to lowercase, strips whitespace, and removes all non-alphanumeric characters.
    This handles differences like ' & ' vs ' and ' vs ' - '
    """
    if not name:
        return ""
    # 1. Lowercase and strip whitespace
    normalized = name.strip().lower()
    # 2. Remove all characters that are not letters or digits (0-9, a-z)
    # This turns "Meetings & Events" and "Meetings and Events" into "meetingsandevents"
    normalized = re.sub(r'[^a-z0-9]', '', normalized)
    return normalized
# --- END NEW UTILITY FUNCTION ---


def get_config_filepath(file_prefix: str) -> str:
    """Constructs the unique config.json filepath based on the prefix."""
    config_filename = f"{file_prefix}_config.json"
    return os.path.join(UPLOAD_FOLDER, config_filename)

def load_settings(file_prefix: str) -> Dict[str, Any] | None:
    """Loads the settings/config file based on the unique prefix."""
    filepath = get_config_filepath(file_prefix)
    if not os.path.exists(filepath):
        print(f"Module Processor: Config file not found at {filepath}")
        return None
    try:
        with open(filepath, "r") as f:
            return json.load(f)
    except Exception as e:
        print(f"Module Processor: Error loading config file: {e}")
        return None

# --- NEW UTILITY FUNCTION TO SAVE PROCESSED JSON ---
def save_processed_json(file_prefix: str, data: Dict[str, Any]) -> bool:
    """Saves the processed JSON data back to its file."""
    processed_filename = f"{file_prefix}{PROCESSED_FILENAME_SUFFIX}"
    filepath = os.path.join(UPLOAD_FOLDER, processed_filename)
    try:
        with open(filepath, "w") as f:
            json.dump(data, f, indent=4)
        print(f"âœ… Successfully saved updated processed JSON to {filepath}")
        return True
    except Exception as e:
        print(f"Module Processor: Error saving processed JSON file: {e}")
        return False
# --- END NEW UTILITY FUNCTION ---

# --- NEW FUNCTION: Placeholder for creating a category ---
def createCategory(page_name: str, site_id: str):
    """Placeholder function to simulate calling the API to create a new category."""
    print(f"\nâš™ï¸ Calling createCategory for Page Name: '{page_name}' (Site ID: {site_id})...")
    # Placeholder print statement as requested
    print("TODO: Implement API call to /api/PageApi/CreateCategory in the next step.")


# --- MODIFIED FUNCTION: Load the JSON result from the XML processing step ---
def load_processed_json(file_prefix: str) -> Dict[str, Any] | None:
    """
    Loads the JSON file generated by the process_xml step, using the new 
    specific filename format: {file_prefix}{SUFFIX}.
    
    If the file is not found, it creates a mock file for testing the comparison logic,
    which now includes multiple pages for testing iteration.
    """
    # 1. Construct the full, expected filepath
    processed_filename = f"{file_prefix}{PROCESSED_FILENAME_SUFFIX}"
    filepath = os.path.join(UPLOAD_FOLDER, processed_filename)
    
    # 2. Check if the file exists
    if not os.path.exists(filepath):
        print(f"Module Processor: Processed JSON file not found at {filepath}")
        print("âš ï¸ CREATING MOCK DATA for testing category search logic (using the required file name structure).")
        
        # --- MOCK DATA CREATION (Temporary for testing) ---
        # Mock data now contains two Level 1 pages: one that will match, one that won't
        mock_data = {
            "title": "394279 Nationwide Hotel & Conference Center",
            "pages": [
                {
                    "page_name": "Our Property",  # EXPECTED TO MATCH
                    "components": [],
                    "meta_info": {},
                    "sub_pages": []
                },
                {
                    "page_name": "Meetings and Events", # Source uses 'and'
                    "components": [],
                    "meta_info": {},
                    "sub_pages": []
                }
            ]
        }
        
        try:
            with open(filepath, "w") as f:
                json.dump(mock_data, f, indent=4)
            print(f"âœ… Mock processed JSON created successfully at {filepath}. Continuing with mock data.")
            return mock_data 
        except Exception as e:
            print(f"Module Processor: Error creating mock JSON file: {e}")
            return None
        # --- END MOCK DATA CREATION ---

    # 3. Load the actual file
    try:
        with open(filepath, "r") as f:
            return json.load(f)
    except Exception as e:
        print(f"Module Processor: Error loading processed JSON file: {e}")
        return None

    
def run_module_processing_step(
    input_filepath: str, 
    step_config: Dict[str, Any], 
    previous_step_data: Dict[str, Any]
) -> Dict[str, Any]:
    """
    The main execution function for the module processing step.
    Loads user config (including the generated token) and calls the API to fetch modules.
    Then, it compares ALL main page names from the processed JSON against the fetched categories,
    and saves the CategoryId for matched pages back into the JSON structure.
    """
    # 1. Get the unique file prefix from the previous step's data
    file_prefix = previous_step_data.get('file_prefix')
    if not file_prefix:
        raise ValueError("Module Processing failed: Missing unique file prefix.")

    # 2. Load settings to get the target URL, Site ID, and token
    settings = load_settings(file_prefix)
    if not settings:
        raise RuntimeError("Could not load user configuration. Aborting module processing.")

    target_url = settings.get("target_site_url")
    site_id = settings.get("site_id")
    auth_token_payload = settings.get("destination_token") 
    
    if not target_url or not auth_token_payload or not site_id:
        raise ValueError("Error: Target URL, Site ID, or Login Token missing in configuration. Cannot fetch modules.")
    
    # --- Logic: Load and extract ALL target page names ---
    processed_json = load_processed_json(file_prefix)
    level1_page_names: List[str] = [] # Used only for initial logging
    
    if processed_json and 'pages' in processed_json and isinstance(processed_json['pages'], list):
        for page in processed_json['pages']:
            if 'page_name' in page:
                level1_page_names.append(page['page_name'])
        
        print(f"\nâœ… Extracted {len(level1_page_names)} Level 1 Page Name(s) from processed JSON: {level1_page_names}")
    else:
        print("âš ï¸ Could not extract Level 1 Page Names. Check processed JSON structure.")
        processed_json = {'pages': []} # Ensure processed_json['pages'] is iterable
            
    if not processed_json['pages']:
        print("Skipping category check as no Level 1 Page was found to process.")
        return {
            "modules_fetched_count": 0,
            "file_prefix": file_prefix
        }

    # 3. Extract the raw token value.
    if not isinstance(auth_token_payload, dict):
        raise TypeError(f"Expected 'destination_token' to be a dictionary, but received {type(auth_token_payload)}.")

    raw_token = auth_token_payload.get('token')

    if not raw_token:
         raise ValueError("Token value 'token' not found in authentication payload.")

    # 4. Construct the required headers
    headers = {
        'Content-Type': 'application/json',
        'ms_cms_clientapp': 'ProgrammingApp',
        'Authorization': f'Bearer {raw_token}',
    }

    print(f"Module Processor: Attempting to fetch modules from {target_url}...")
    
    # 5. Call the API to get the category list
    api_result: Union[List[Dict[str, Any]], Dict[str, Any]] = GetPageCategoryList(target_url, headers)
    
    # --- Error Handling ---
    if isinstance(api_result, dict) and 'error' in api_result:
        error_type = api_result.get('error', 'Unknown Error')
        details = api_result.get('details', 'No details provided.')
        status_code = api_result.get('status_code', 'N/A')
        
        raise RuntimeError(f"API Call Failed ({error_type}, Status: {status_code}). Details: {details}")
    
    module_list = api_result
        
    if not isinstance(module_list, list):
         raise RuntimeError(f"API returned data, but it was not the expected list structure. Type received: {type(module_list)}")

    print(f"Module Processor: Successfully retrieved {len(module_list)} modules.")
    
    # 6. Logic: Search for ALL page names in the retrieved modules and map the results
    print("\n--- Category Matching and ID Retrieval Process ---")
    
    # Create a dictionary for efficient fuzzy lookup: normalized_name -> category_object (with ID)
    normalized_category_map: Dict[str, Dict[str, Any]] = {}
    for module in module_list:
        category_name = module.get('CategoryName')
        category_id = module.get('CategoryId')
        if category_name and category_id is not None:
            normalized_name = normalize_page_name(category_name)
            normalized_category_map[normalized_name] = {
                'CategoryId': category_id,
                'CategoryName': category_name
            }

    pages_updated = 0
    
    # Iterate directly over the page objects in the processed_json so we can modify them
    for page in processed_json['pages']:
        page_name = page.get('page_name')
        if not page_name:
            continue

        normalized_page_name = normalize_page_name(page_name)
        
        print(f"\nðŸ” Checking Page Name: '{page_name}' (Normalized: '{normalized_page_name}')")

        # Look up category info using the normalized name
        category_info = normalized_category_map.get(normalized_page_name)

        if category_info:
            # MATCH FOUND: Extract ID and update the page object
            category_id = category_info['CategoryId']
            category_name_api = category_info['CategoryName']

            page['category_info'] = {
                'CategoryId': category_id,
                'CategoryName': category_name_api,
                'match_type': 'fuzzy_name_match'
            }
            pages_updated += 1
            
            print("âœ… match found") 
            print(f"âœ… FOUND: Page '{page_name}' matches Category ID {category_id} ('{category_name_api}').")
        else:
            print(f"âŒ NOT FOUND: Page '{page_name}' does not match an existing Category.")
            # Call the creation function if no match is found
            createCategory(page_name, site_id)
        
    # 7. Final step: Save the updated JSON data back to disk
    if pages_updated > 0 and processed_json:
        save_processed_json(file_prefix, processed_json)
    elif processed_json:
        print("No new category information was added to the processed JSON, skipping save.")

    print(f"\n--- API Fetch Results ---")
    print(f"Total items fetched: {len(module_list)}")
    print("--------------------------\n")
    
    return {
        "modules_fetched_count": len(module_list),
        "pages_checked_count": len(level1_page_names),
        "pages_updated_with_category_id": pages_updated,
        "file_prefix": file_prefix # Continue propagating the prefix
    }