{% extends "base_dashboard.html" %}
{% block content %}
<div class="fade-in">
  <div class="alert alert-info border-0 mb-4" style="background: rgba(168, 199, 250, 0.12);">
    <div class="d-flex align-items-start gap-2">
      <span class="material-icons-round text-primary">edit_note</span>
      <div>
        <strong>Live Trading (NIFTY / BANKNIFTY):</strong>
        <ul class="mb-0 mt-2 small">
          <li>Live-only page: orders are placed in your connected Zerodha account.</li>
          <li>Engine, table and AI refresh every 1 minute (no conflict).</li>
          <li>Select index and capital, then click Trade to start a live session.</li>
          <li><strong>P&amp;L:</strong> Unrealized P&amp;L updates with price. When stop is hit, loss is capped by configured live risk limits.</li>
          <li><strong>Refresh:</strong> Active sessions are saved on the server; refreshing the page does not stop them.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- AI & Strategy (same as Backtest) -->
  <div class="card mb-4">
    <div class="card-header d-flex align-items-center justify-content-between">
      <div class="d-flex align-items-center gap-2">
        <span class="material-icons-round text-primary-custom">smart_toy</span>
        AI &amp; Strategy
      </div>
      <div class="form-check form-switch mb-0">
        <input class="form-check-input" type="checkbox" id="paper-enable-ai-switching" checked>
        <label class="form-check-label" for="paper-enable-ai-switching">Enable AI Auto-Switching</label>
      </div>
    </div>
    <div class="card-body">
      <div class="row g-3">
        <div class="col-md-4">
          <label class="form-label small">Strategy (disabled when AI ON)</label>
          <select class="form-select form-select-sm" id="paper-strategy" disabled>
            <option value="AI_AUTO">AI Auto-Select</option>
            <option value="Index Momentum">Index Momentum</option>
            <option value="Momentum Breakout">Momentum Breakout</option>
            <option value="VWAP Trend Ride">VWAP Trend Ride</option>
            <option value="RSI Reversal Fade">RSI Reversal Fade</option>
            <option value="Opening Range Breakout">Opening Range Breakout</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <div class="row g-3 mb-4">
    <div class="col-12 col-md-6 col-lg-3">
      <div class="card h-100">
        <div class="card-header d-flex align-items-center gap-2">
          <span class="material-icons-round text-primary-custom">account_balance</span>
          Zerodha Balance
        </div>
        <div class="card-body">
          <div class="d-flex align-items-baseline gap-2">
            <span class="metric-value" id="zerodha-balance">—</span>
            <span class="text-muted small" id="zerodha-balance-status"></span>
          </div>
          <p class="text-muted small mb-0 mt-1">Before investment (live)</p>
        </div>
      </div>
    </div>
    <div class="col-12 col-md-6 col-lg-3">
      <div class="card h-100">
        <div class="card-header d-flex align-items-center gap-2">
          <span class="material-icons-round text-primary-custom">savings</span>
          Investment Amount
        </div>
        <div class="card-body">
          <input type="number" class="form-control" id="investment-amount" value="10000" min="1000" step="5000" placeholder="e.g. 10000">
          <p class="text-muted small mb-0 mt-1">Capital for today</p>
        </div>
      </div>
    </div>
    <div class="col-12 col-md-6 col-lg-3">
      <div class="card h-100">
        <div class="card-header d-flex align-items-center gap-2">
          <span class="material-icons-round text-primary-custom">shield</span>
          Risk Limits
        </div>
        <div class="card-body">
          <div class="mb-2">
            <label class="form-label small mb-1">Risk Per Trade (Value)</label>
            <input type="number" class="form-control form-control-sm" id="paper-risk-amount" value="300" min="1" step="50" placeholder="300">
          </div>
          <div class="mb-0">
            <label class="form-label small mb-1">Daily Loss Limit (Value)</label>
            <input type="number" class="form-control form-control-sm" id="paper-daily-loss-limit" value="3000" min="1" step="100" placeholder="3000">
          </div>
        </div>
      </div>
    </div>
    <div class="col-12 col-md-6 col-lg-3">
      <div class="card h-100">
        <div class="card-header d-flex align-items-center gap-2">
          <span class="material-icons-round text-primary-custom">candlestick_chart</span>
          Instrument &amp; Trade
        </div>
        <div class="card-body">
          <div class="mb-2">
            <label class="form-label small mb-1">Index</label>
            <select class="form-select" id="paper-instrument">
              <option value="NIFTY">NIFTY 50</option>
              <option value="BANKNIFTY">BANK NIFTY</option>
            </select>
          </div>
          <button type="button" class="btn btn-primary w-100 d-flex align-items-center justify-content-center gap-2" id="paper-trade-btn">
            <span class="material-icons-round">trending_up</span> Trade
          </button>
          <div id="paper-trade-status" class="mt-2 small"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="card mb-3">
    <div class="card-body py-2 px-3 d-flex flex-wrap align-items-center gap-3 gap-md-4">
      <span class="text-muted small d-flex align-items-center gap-1" id="engine-status-wrap">
        <span class="rounded-circle d-inline-block" id="engine-dot" style="width: 8px; height: 8px; background: var(--bs-secondary);"></span>
        <span id="engine-status-text">Engine: —</span>
      </span>
      <span class="text-muted small" id="engine-scan-countdown">Next engine scan: —</span>
      <span class="text-muted small" id="ai-check-countdown">Next AI check: —</span>
      <span class="badge bg-secondary text-light" id="live-entry-window-badge">LIVE entry window: —</span>
      <span class="badge bg-info text-dark" id="market-threshold-badge">Market score/threshold: —</span>
      <span class="badge bg-secondary text-light" id="expiry-awareness-badge" style="display: none;"></span>
      <span class="badge bg-warning text-dark" id="cooldown-active-badge" style="display: none;"></span>
      <span class="text-muted small" id="session-active-badge" style="display: none;"></span>
    </div>
  </div>

  <div class="card mb-3">
    <div class="card-header d-flex align-items-center gap-2">
      <span class="material-icons-round text-primary-custom">tune</span>
      Entry Score Threshold Control
    </div>
    <div class="card-body">
      <div class="row g-3 align-items-end">
        <div class="col-12 col-md-3">
          <label class="form-label small mb-1">Current Threshold</label>
          <div class="badge bg-info text-dark w-100 py-2" id="entry-threshold-current-badge">—</div>
        </div>
        <div class="col-12 col-md-3">
          <label class="form-label small mb-1">Set Threshold</label>
          <input type="number" class="form-control form-control-sm" id="entry-threshold-input" min="35" max="90" step="1" value="55">
        </div>
        <div class="col-12 col-md-2">
          <button type="button" class="btn btn-sm btn-primary w-100" id="entry-threshold-save-btn">Apply</button>
        </div>
        <div class="col-12 col-md-4">
          <div class="small text-muted" id="entry-threshold-save-status"></div>
        </div>
      </div>
      <hr class="my-3">
      <div class="small">
        <strong>Best Threshold Suggestion:</strong>
        <span id="entry-threshold-suggestion" class="text-info">Balanced: 55</span>
      </div>
      <div class="small text-muted mt-1" id="entry-threshold-guidance">
        Aggressive: 45 (more entries, more charges) | Balanced: 55 | Defensive: 65 (fewer, higher-conviction entries)
      </div>
    </div>
  </div>

  <div class="card mb-3">
    <div class="card-header d-flex align-items-center gap-2">
      <span class="material-icons-round text-primary-custom">summarize</span>
      Today Overall Status
    </div>
    <div class="card-body py-2 px-3 d-flex flex-wrap align-items-center gap-3 gap-md-4">
      <span class="badge bg-primary bg-opacity-10 text-primary-custom" id="overall-trades-count">0 trades</span>
      <span class="text-muted small">Live Net: <span id="overall-live-net">₹0.00</span></span>
    </div>
  </div>

  <!-- Live trades (today) -->
  <div class="card">
    <div class="card-header d-flex align-items-center justify-content-between flex-wrap gap-2">
      <div class="d-flex align-items-center gap-2">
        <span class="material-icons-round text-primary-custom">show_chart</span>
        Live trades (today)
      </div>
      <div class="d-flex align-items-center gap-2">
        <span class="badge bg-primary bg-opacity-10 text-primary-custom" id="live-executions-count">0</span>
        <span class="badge bg-secondary bg-opacity-25 text-light" id="live-positions-total-pnl">Total P&amp;L —</span>
        <button type="button" class="btn btn-sm btn-outline-danger" id="live-stop-btn" style="display: none;">
          <span class="material-icons-round" style="font-size: 1rem;">stop_circle</span> Stop Live
        </button>
      </div>
    </div>
    <div id="live-sessions-waiting-msg" class="alert alert-secondary border-0 mb-0 rounded-0 small py-2 px-3" style="display: none;"></div>
    <div class="card-body p-0">
      <div class="table-responsive overflow-x-auto" style="max-width: 100%; overflow-x: auto;">
        <table class="table table-sm table-dark table-hover mb-0" style="min-width: 1500px; white-space: nowrap;">
          <thead>
            <tr>
              <th>Date</th>
              <th>CE/PE</th>
              <th>Strike</th>
              <th>Strategy</th>
              <th>Entry Time</th>
              <th>Exit Time</th>
              <th>Entry Price</th>
              <th>Exit Price</th>
              <th>Current price</th>
              <th>Qty</th>
              <th>Price/Lot</th>
              <th>Capital Used</th>
              <th>Balance Left</th>
              <th>Gross P&L</th>
              <th>Charges</th>
              <th>Net P&L</th>
              <th>Risk-Capped P&L</th>
              <th>Status</th>
              <th>Exit Reason</th>
            </tr>
          </thead>
          <tbody id="live-executions-tbody">
            <tr><td colspan="20" class="text-center text-muted py-4">No live trades today.</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Today full history (executed + open) -->
  <div class="card mt-4">
    <div class="card-header d-flex align-items-center justify-content-between flex-wrap gap-2">
      <div class="d-flex align-items-center gap-2">
        <span class="material-icons-round text-primary-custom">history</span>
        Today full history (executed + open)
      </div>
      <div class="d-flex align-items-center gap-2">
        <span class="badge bg-success bg-opacity-25 text-success" id="today-full-history-executed-count">Executed: 0</span>
        <span class="badge bg-info bg-opacity-25 text-info" id="today-full-history-charges-total">Charges (Est.): ₹0.00</span>
        <span class="badge bg-primary bg-opacity-10 text-primary-custom" id="today-full-history-count">0</span>
      </div>
    </div>
    <div class="card-body p-0">
      <div class="table-responsive overflow-x-auto" style="max-width: 100%; overflow-x: auto;">
        <table class="table table-sm table-dark table-hover mb-0" style="min-width: 1200px; white-space: nowrap;">
          <thead>
            <tr>
              <th>Time</th>
              <th>Mode</th>
              <th>Instrument</th>
              <th>Symbol</th>
              <th>Strategy</th>
              <th>Status</th>
              <th>Entry</th>
              <th>Exit</th>
              <th>Qty</th>
              <th>Gross P&amp;L</th>
              <th>Net P&amp;L</th>
              <th>Charges (Est.)</th>
              <th>Exit Reason</th>
            </tr>
          </thead>
          <tbody id="today-full-history-tbody">
            <tr><td colspan="13" class="text-center text-muted py-4">No today history.</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>

{% endblock %}

{% block scripts %}
{{ super() }}
<script>
(function() {
  let dataRefreshSecs = 60;
  let countdownTimer = null;
  let optimisticRows = [];
  let activePaperSessionId = null;
  let activeLiveSessionId = null;
  let engineNextScanSecs = null;
  let nextAiCheckSecs = null;
  let nextAiCheckDisplaySecs = null;
  let engineRunning = true;
  let aiExpiryAwareness = null;
  let isExpiryDay = null;
  let expiryType = null;
  let entryScoreThreshold = null;
  let entryThresholdMin = 35;
  let entryThresholdMax = 90;
  let lastStatusSyncMs = 0;

  function getTradeMode() {
    return 'LIVE';
  }

  function formatTime(iso) {
    if (!iso) return '—';
    try {
      const d = new Date(iso);
      return d.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    } catch (e) { return iso; }
  }
  function formatDate(iso) {
    if (!iso) return '—';
    try {
      return (iso + '').slice(0, 10);
    } catch (e) { return iso; }
  }
  function fmtNum(v) {
    if (v == null || v === '' || v === '—') return '—';
    const n = Number(v);
    if (isNaN(n)) return '—';
    return '₹' + n.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  function getIstTimeParts() {
    try {
      const parts = new Intl.DateTimeFormat('en-GB', {
        timeZone: 'Asia/Kolkata',
        hour12: false,
        hour: '2-digit',
        minute: '2-digit'
      }).formatToParts(new Date());
      const hour = Number((parts.find(p => p.type === 'hour') || {}).value || 0);
      const minute = Number((parts.find(p => p.type === 'minute') || {}).value || 0);
      return { hour, minute };
    } catch (e) {
      const d = new Date();
      return { hour: d.getHours(), minute: d.getMinutes() };
    }
  }

  function isInMinuteRange(mins, startH, startM, endH, endM) {
    const start = startH * 60 + startM;
    const end = endH * 60 + endM;
    return mins >= start && mins <= end;
  }

  function updateLiveEntryWindowBadge() {
    const badge = document.getElementById('live-entry-window-badge');
    if (!badge) return;
    const tp = getIstTimeParts();
    const mins = (Number(tp.hour) * 60) + Number(tp.minute);
    const inMorning = isInMinuteRange(mins, 9, 25, 10, 45);
    const inAfternoon = isInMinuteRange(mins, 13, 15, 15, 10);
    const isOpen = inMorning || inAfternoon;
    badge.classList.remove('bg-secondary', 'bg-success', 'bg-danger', 'text-light', 'text-dark');
    if (isOpen) {
      badge.classList.add('bg-success', 'text-light');
      badge.textContent = 'LIVE entry window: OPEN';
    } else {
      badge.classList.add('bg-danger', 'text-light');
      badge.textContent = 'LIVE entry window: CLOSED';
    }
    badge.title = 'Allowed: 09:25-10:45 and 13:15-15:10 IST. Active trade is managed normally; only new entries are blocked when closed.';
  }

  function clampThreshold(v) {
    const n = Number(v);
    if (!isFinite(n)) return entryScoreThreshold != null ? Number(entryScoreThreshold) : 55;
    return Math.max(entryThresholdMin, Math.min(entryThresholdMax, Math.round(n)));
  }

  function updateEntryThresholdUI() {
    const value = (entryScoreThreshold != null) ? Number(entryScoreThreshold) : null;
    const text = (value != null) ? String(value) : '—';
    const currentBadge = document.getElementById('entry-threshold-current-badge');
    if (currentBadge) currentBadge.textContent = text;
    const input = document.getElementById('entry-threshold-input');
    if (input && value != null) input.value = String(value);
  }

  function updateCurrentMarketThresholdBadge(sessions) {
    const badge = document.getElementById('market-threshold-badge');
    if (!badge) return;
    const list = Array.isArray(sessions) ? sessions : [];
    const activeLive = list.find(s => String(s.status || '').toUpperCase() === 'ACTIVE' && String((s.execution_mode || s.mode || '')).toUpperCase() === 'LIVE');
    const diag = activeLive && activeLive.entry_diagnostics ? activeLive.entry_diagnostics : null;
    const score = diag && Number.isFinite(Number(diag.total_score)) ? Number(diag.total_score) : null;
    const thresholdFromDiag = diag && diag.conditions && Number.isFinite(Number(diag.conditions.entry_score_threshold))
      ? Number(diag.conditions.entry_score_threshold)
      : null;
    const threshold = thresholdFromDiag != null
      ? thresholdFromDiag
      : (entryScoreThreshold != null ? Number(entryScoreThreshold) : null);

    badge.classList.remove('bg-info', 'bg-success', 'bg-warning', 'bg-danger', 'text-dark', 'text-light');
    if (score != null && threshold != null) {
      const ok = score >= threshold;
      badge.classList.add(ok ? 'bg-success' : 'bg-warning', 'text-dark');
      badge.textContent = `Market score/threshold: ${score}/${threshold}`;
      badge.title = ok
        ? 'Current setup is above threshold (entry can pass quality gate).'
        : 'Current setup is below threshold (quality gate blocks entry).';
      return;
    }
    if (threshold != null) {
      badge.classList.add('bg-info', 'text-dark');
      badge.textContent = `Market score/threshold: —/${threshold}`;
      badge.title = 'Waiting for latest live score from active session.';
      return;
    }
    badge.classList.add('bg-secondary', 'text-light');
    badge.textContent = 'Market score/threshold: —';
    badge.title = '';
  }

  function updateThresholdSuggestionFromSession(sessions) {
    const el = document.getElementById('entry-threshold-suggestion');
    if (!el) return;
    const list = Array.isArray(sessions) ? sessions : [];
    const active = list.find(s => (String(s.status || '').toUpperCase() === 'ACTIVE'));
    const diag = active && active.entry_diagnostics ? active.entry_diagnostics : null;
    const b = (diag && diag.score_breakdown) ? diag.score_breakdown : null;
    if (!b) {
      el.textContent = 'Balanced: 55';
      return;
    }
    const momentum = Number(b.momentum || 0);
    const ai = Number(b.ai || 0);
    if (momentum <= 0 && ai <= 8) {
      el.textContent = 'Current market suggests 45-50 (slow/choppy)';
    } else if (momentum >= 12 && ai >= 22) {
      el.textContent = 'Current market suggests 60-65 (strong conviction)';
    } else {
      el.textContent = 'Current market suggests 55 (balanced)';
    }
  }

  function fetchEntryThreshold() {
    return fetch('/api/settings/entry-threshold')
      .then(r => r.json())
      .then(data => {
        if (!data || data.ok === false) return;
        if (typeof data.min === 'number') entryThresholdMin = Number(data.min);
        if (typeof data.max === 'number') entryThresholdMax = Number(data.max);
        if (typeof data.threshold === 'number') entryScoreThreshold = Number(data.threshold);
        updateEntryThresholdUI();
      })
      .catch(() => {});
  }

  function saveEntryThreshold() {
    const input = document.getElementById('entry-threshold-input');
    const status = document.getElementById('entry-threshold-save-status');
    if (!input) return;
    const nextVal = clampThreshold(input.value);
    if (status) status.innerHTML = '<span class="text-primary">Updating threshold…</span>';
    fetch('/api/settings/entry-threshold', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ threshold: nextVal })
    })
      .then(r => r.json())
      .then(data => {
        if (data && data.ok) {
          entryScoreThreshold = Number(data.threshold);
          updateEntryThresholdUI();
          if (status) status.innerHTML = '<span class="text-success">Threshold updated.</span>';
          fetchExecutions();
        } else {
          if (status) status.innerHTML = '<span class="text-danger">' + ((data && data.error) || 'Failed to update threshold') + '</span>';
        }
      })
      .catch(() => {
        if (status) status.innerHTML = '<span class="text-danger">Request failed</span>';
      });
  }

  function fetchRiskConfig() {
    const amt = parseFloat(document.getElementById('investment-amount').value) || 10000;
    const dailyInput = document.getElementById('paper-daily-loss-limit');
    if (dailyInput && (!dailyInput.value || Number(dailyInput.value) <= 0)) {
      dailyInput.value = Math.max(3000, Math.round(amt * 0.3));
    }
  }

  function fetchBalance() {
    fetch('/api/account-balance?mode=LIVE')
      .then(r => r.json())
      .then(data => {
        const el = document.getElementById('zerodha-balance');
        const status = document.getElementById('zerodha-balance-status');
        if (data.balance != null) {
          el.textContent = '₹' + Number(data.balance).toLocaleString('en-IN', { minimumFractionDigits: 2 });
          status.textContent = data.mode || '';
        } else {
          el.textContent = '—';
          status.textContent = 'Not connected';
        }
      })
      .catch(() => {
        document.getElementById('zerodha-balance').textContent = '—';
        document.getElementById('zerodha-balance-status').textContent = 'Error';
      });
  }

  function runRefresh() {
    dataRefreshSecs = 60;
    fetchEngineStatus();
    fetchBalance();
    fetchExecutions();
  }

  function safeJson(r) {
    if (!r.ok) throw new Error('API ' + r.status);
    return r.json().catch(function() { throw new Error('Invalid JSON'); });
  }

  function fetchJsonWithTimeout(url, timeoutMs) {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs || 12000);
    return fetch(url, { signal: controller.signal })
      .then(safeJson)
      .finally(() => clearTimeout(timer));
  }

  function fetchEngineStatus() {
    return fetchJsonWithTimeout('/api/engine/status', 8000)
      .then(function(data) {
        if (!data || typeof data !== 'object') return;
        if (typeof data.running === 'boolean') {
          engineRunning = data.running;
        }
        if (typeof data.next_scan_in_seconds === 'number') {
          engineNextScanSecs = data.next_scan_in_seconds;
        } else if (typeof data.next_scan_sec === 'number') {
          engineNextScanSecs = data.next_scan_sec;
        }
        if (typeof data.entry_score_threshold === 'number') {
          entryScoreThreshold = Number(data.entry_score_threshold);
          updateEntryThresholdUI();
        }
        if (typeof data.ai_expiry_awareness === 'boolean') aiExpiryAwareness = data.ai_expiry_awareness;
        if (typeof data.is_expiry_day === 'boolean') isExpiryDay = data.is_expiry_day;
        expiryType = data.expiry_type || null;
        lastStatusSyncMs = Date.now();
        updateExpiryAwarenessBadge();
        updateEngineStatusUI();
      })
      .catch(function() {
        // Keep last known engine status; avoid blanking UI on transient timeout.
      });
  }

  function fetchExecutions() {
    Promise.all([
      fetchJsonWithTimeout('/api/trade-history?mode=LIVE&today=1', 12000),
      fetchJsonWithTimeout('/api/trade-sessions', 12000),
      fetchJsonWithTimeout('/api/live-executions-today?today=1', 12000),
      fetchJsonWithTimeout('/api/live-positions-today?exchange=NFO', 12000)
    ]).then(([liveData, sessionsData, brokerExecData, livePosData]) => {
      try {
        const paperTrades = [];
        const liveTrades = (liveData && liveData.trades) ? liveData.trades : [];
        updateOverallStatus(paperTrades, liveTrades);
        const sessions = (sessionsData && sessionsData.sessions) ? sessionsData.sessions : [];
        var modeKey = function(s) { return (s.execution_mode || s.mode || '').toUpperCase(); };
        const paperOpen = [];
        const paperWaiting = [];
        const paperActive = [];
        const liveOpen = sessions.filter(s => modeKey(s) === 'LIVE' && s.status === 'ACTIVE' && s.current_trade);
        const liveWaiting = sessions.filter(s => modeKey(s) === 'LIVE' && s.status === 'ACTIVE' && !s.current_trade);
        const liveActive = sessions.filter(s => modeKey(s) === 'LIVE' && s.status === 'ACTIVE');
        updateCooldownBadge(sessions);
        
        if (liveOpen.length > 0) optimisticRows = optimisticRows.filter(o => (o.mode || 'LIVE') !== 'LIVE');
        if (sessionsData != null) {
          engineRunning = sessionsData.engine_running !== false;
          engineNextScanSecs = typeof sessionsData.next_scan === 'number' ? sessionsData.next_scan : null;
          if (typeof sessionsData.entry_score_threshold === 'number') {
            entryScoreThreshold = Number(sessionsData.entry_score_threshold);
          }
          var raw = sessionsData.next_ai_check_secs;
          nextAiCheckSecs = (typeof raw === 'number' && !isNaN(raw)) ? raw : null;
          if (typeof sessionsData.ai_expiry_awareness === 'boolean') aiExpiryAwareness = sessionsData.ai_expiry_awareness;
          if (typeof sessionsData.is_expiry_day === 'boolean') isExpiryDay = sessionsData.is_expiry_day;
          expiryType = sessionsData.expiry_type || expiryType;
          if (nextAiCheckSecs == null && (paperActive.length > 0 || liveActive.length > 0)) {
            nextAiCheckSecs = 60;
          }
          if (nextAiCheckSecs != null && nextAiCheckSecs >= 0) nextAiCheckDisplaySecs = nextAiCheckSecs;
          lastStatusSyncMs = Date.now();
        }
        updateEntryThresholdUI();
        updateCurrentMarketThresholdBadge(sessions);
        updateThresholdSuggestionFromSession(sessions);
        updateExpiryAwarenessBadge();
        updateEngineStatusUI();
        var liveActiveCount = liveActive.length;
        var badgeEl = document.getElementById('session-active-badge');
        if (badgeEl) {
          if (liveActiveCount > 0) {
            badgeEl.style.display = '';
            badgeEl.textContent = liveActiveCount + ' Live session(s) active';
          } else {
            badgeEl.style.display = 'none';
          }
        }
        const brokerOrders = (brokerExecData && brokerExecData.orders) ? brokerExecData.orders : [];
        const livePositions = (livePosData && livePosData.positions) ? livePosData.positions : [];
        renderModeExecutions('LIVE', liveTrades, liveOpen, liveWaiting.length, liveActive, brokerOrders, livePositions);
        renderTodayFullHistory(paperTrades, liveTrades, paperOpen, liveOpen, paperWaiting, liveWaiting, brokerOrders);
      } catch (e) {
        // Keep last-rendered table if parsing fails; avoid "vanishing" active sessions.
      }
    }).catch(function() {
      // Keep last-rendered table and last-known engine status while reconnecting.
      fetchEngineStatus();
    });
  }

  function updateExpiryAwarenessBadge() {
    var badge = document.getElementById('expiry-awareness-badge');
    if (!badge) return;
    badge.classList.remove('bg-secondary', 'bg-warning', 'bg-info', 'bg-primary', 'text-light', 'text-dark');

    if (aiExpiryAwareness === false) {
      badge.style.display = '';
      badge.classList.add('bg-primary', 'text-light');
      badge.textContent = 'AI expiry context unavailable';
      return;
    }

    if (isExpiryDay) {
      var t = String(expiryType || 'EXPIRY').toUpperCase();
      badge.style.display = '';
      badge.classList.add('bg-primary', 'text-light');
      badge.textContent = 'AI expiry aware: ' + t + ' EXPIRY';
      return;
    }

    if (aiExpiryAwareness === true) {
      badge.style.display = '';
      badge.classList.add('bg-primary', 'text-light');
      badge.textContent = 'AI expiry aware: NON-EXPIRY';
      return;
    }

    badge.style.display = 'none';
  }

  function updateCooldownBadge(sessions) {
    const badge = document.getElementById('cooldown-active-badge');
    if (!badge) return;
    const now = new Date();
    let nearest = null;
    let nearestMode = null;
    let nearestSessionId = null;
    (sessions || []).forEach(s => {
      if ((s.status || '').toUpperCase() !== 'ACTIVE') return;
      if (!s.cooldown_until) return;
      const dt = new Date(s.cooldown_until);
      if (isNaN(dt.getTime())) return;
      if (dt <= now) return;
      if (!nearest || dt < nearest) {
        nearest = dt;
        nearestMode = ((s.execution_mode || s.mode || '') + '').toUpperCase() || 'SESSION';
        nearestSessionId = s.sessionId || s.session_id || null;
      }
    });
    if (!nearest) {
      badge.style.display = 'none';
      badge.dataset.sessionId = '';
      badge.style.cursor = '';
      badge.title = '';
      return;
    }
    const t = nearest.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' });
    badge.textContent = `${nearestMode} COOLDOWN ACTIVE until ${t} (Click to reset)`;
    badge.style.display = '';
    badge.dataset.sessionId = nearestSessionId || '';
    badge.style.cursor = nearestSessionId ? 'pointer' : '';
    badge.title = nearestSessionId ? 'Click to reset cooldown now' : '';
  }

  function sumNetPnl(trades) {
    if (!Array.isArray(trades)) return 0;
    return trades.reduce((acc, t) => {
      const net = t && t.net_pnl != null ? Number(t.net_pnl) : (t && t.pnl != null ? Number(t.pnl) : 0);
      return acc + (isNaN(net) ? 0 : net);
    }, 0);
  }

  function applyPnlColor(el, value) {
    if (!el) return;
    el.classList.remove('text-success', 'text-danger');
    if (value > 0) el.classList.add('text-success');
    else if (value < 0) el.classList.add('text-danger');
  }

  function updateOverallStatus(paperTrades, liveTrades) {
    const liveNet = sumNetPnl(liveTrades);
    const tradesCount = (Array.isArray(liveTrades) ? liveTrades.length : 0);

    const countEl = document.getElementById('overall-trades-count');
    const liveEl = document.getElementById('overall-live-net');

    if (countEl) countEl.textContent = `${tradesCount} trade${tradesCount === 1 ? '' : 's'}`;
    if (liveEl) {
      liveEl.textContent = fmtNum(liveNet);
      applyPnlColor(liveEl, liveNet);
    }
  }

  function renderTodayFullHistory(paperTrades, liveTrades, paperOpen, liveOpen, paperWaiting, liveWaiting, brokerOrders) {
    const tbody = document.getElementById('today-full-history-tbody');
    const countEl = document.getElementById('today-full-history-count');
    const executedCountEl = document.getElementById('today-full-history-executed-count');
    const chargesTotalEl = document.getElementById('today-full-history-charges-total');
    if (!tbody || !countEl) return;

    function esc(v) {
      return String(v == null ? '' : v).replace(/&/g, '&amp;').replace(/</g, '&lt;');
    }
    function tsOf(iso) {
      const n = Number(new Date(iso || 0));
      return isNaN(n) ? 0 : n;
    }
    function fmtPnl(n) {
      if (n == null || isNaN(Number(n))) return '—';
      const v = Number(n);
      const txt = fmtNum(v);
      const cls = v < 0 ? 'text-danger' : (v > 0 ? 'text-success' : '');
      return `<span class="${cls}">${txt}</span>`;
    }
    // Broker orderbook does not return final settled charges; compute detailed estimate.
    function estimateOrderCharges(side, avgPrice, qty, symbol) {
      const p = Number(avgPrice);
      const q = Number(qty);
      if (!isFinite(p) || !isFinite(q) || p <= 0 || q <= 0) return null;
      const turnover = p * q;
      const isBuy = String(side || '').toUpperCase() === 'BUY';
      const sym = String(symbol || '').toUpperCase();
      const isOptions = /(?:CE|PE)$/.test(sym);
      const brokerage = isOptions ? 20.0 : Math.min(20.0, turnover * 0.0003);
      const txn = turnover * 0.0003503;
      const sebi = turnover * 0.000001;
      const stamp = isBuy ? (turnover * 0.00003) : 0.0;
      const stt = isBuy ? 0.0 : (turnover * 0.001);
      const gst = 0.18 * (brokerage + txn + sebi);
      const total = brokerage + txn + sebi + stamp + stt + gst;
      const r2 = (v) => Math.round((v + Number.EPSILON) * 100) / 100;
      return {
        brokerage: r2(brokerage),
        gst: r2(gst),
        stt: r2(stt),
        txn: r2(txn),
        sebi: r2(sebi),
        stamp: r2(stamp),
        total: r2(total),
      };
    }

    const rows = [];
    let executedCount = 0;
    let executedChargesTotal = 0;
    let executedBreakup = { brokerage: 0, gst: 0, stt: 0, txn: 0, sebi: 0, stamp: 0 };

    (brokerOrders || []).forEach(o => {
      const side = String(o.side || '').toUpperCase();
      const status = String(o.status || '').toUpperCase();
      const avg = o.average_price != null ? Number(o.average_price) : null;
      const qtyNum = Number(o.filled_quantity || o.quantity || 0) || 0;
      const qty = qtyNum || '—';
      const isExecuted = (status === 'COMPLETE' || Number(o.filled_quantity || 0) > 0);
      if (isExecuted) executedCount += 1;
      const estCharges = estimateOrderCharges(side, avg, qtyNum, o.symbol);
      if (isExecuted && estCharges != null) {
        executedChargesTotal += Number(estCharges.total || 0);
        executedBreakup.brokerage += Number(estCharges.brokerage || 0);
        executedBreakup.gst += Number(estCharges.gst || 0);
        executedBreakup.stt += Number(estCharges.stt || 0);
        executedBreakup.txn += Number(estCharges.txn || 0);
        executedBreakup.sebi += Number(estCharges.sebi || 0);
        executedBreakup.stamp += Number(estCharges.stamp || 0);
      }
      const sideBadge = side === 'BUY'
        ? '<span class="badge bg-success">BUY</span>'
        : (side === 'SELL' ? '<span class="badge bg-danger">SELL</span>' : '');
      const statusBadge = (
        (isExecuted
          ? '<span class="badge bg-success">EXECUTED</span>'
          : '<span class="badge bg-secondary">' + esc(status || 'ORDER') + '</span>')
        + (sideBadge ? (' ' + sideBadge) : '')
      );
      rows.push({
        sort_priority: 2,
        sort_ts: tsOf(o.order_timestamp),
        time: formatTime(o.order_timestamp),
        mode: 'LIVE',
        instrument: String(o.exchange || '—').toUpperCase(),
        symbol: o.symbol || '—',
        strategy: 'Broker Order',
        status: statusBadge,
        entry: side === 'BUY' ? fmtNum(avg) : '—',
        exit: side === 'SELL' ? fmtNum(avg) : '—',
        qty: qty,
        gross: '—',
        net: '—',
        charges: estCharges != null
          ? (
              `<div>${fmtNum(estCharges.total)}</div>` +
              `<div class="small text-muted">Br ${fmtNum(estCharges.brokerage)} | GST ${fmtNum(estCharges.gst)} | STT ${fmtNum(estCharges.stt)} | Txn ${fmtNum(estCharges.txn)} | SEBI ${fmtNum(estCharges.sebi)} | Stamp ${fmtNum(estCharges.stamp)}</div>`
            )
          : '—',
        reason: o.status_message || status || '—'
      });
    });

    rows.sort((a, b) => (b.sort_ts || 0) - (a.sort_ts || 0));

    countEl.textContent = String(rows.length);
    if (executedCountEl) executedCountEl.textContent = 'Executed: ' + String(executedCount);
    if (chargesTotalEl) {
      const b = executedBreakup;
      chargesTotalEl.textContent = 'Charges (Est.): ' + fmtNum(executedChargesTotal);
      chargesTotalEl.title =
        'Br ' + fmtNum(b.brokerage) +
        ' | GST ' + fmtNum(b.gst) +
        ' | STT ' + fmtNum(b.stt) +
        ' | Txn ' + fmtNum(b.txn) +
        ' | SEBI ' + fmtNum(b.sebi) +
        ' | Stamp ' + fmtNum(b.stamp);
    }
    if (!rows.length) {
      tbody.innerHTML = '<tr><td colspan="13" class="text-center text-muted py-4">No today history.</td></tr>';
      return;
    }

    tbody.innerHTML = rows.map(r => `
      <tr>
        <td>${esc(r.time)}</td>
        <td>${esc(r.mode)}</td>
        <td>${esc(r.instrument)}</td>
        <td>${esc(r.symbol)}</td>
        <td>${esc(r.strategy)}</td>
        <td>${r.status}</td>
        <td>${r.entry}</td>
        <td>${r.exit}</td>
        <td>${esc(r.qty)}</td>
        <td>${r.gross}</td>
        <td>${r.net}</td>
        <td>${r.charges}</td>
        <td>${esc(r.reason)}</td>
      </tr>
    `).join('');
  }

  function updateEngineStatusUI() {
    var txt = document.getElementById('engine-status-text');
    var dot = document.getElementById('engine-dot');
    var scanEl = document.getElementById('engine-scan-countdown');
    var aiEl = document.getElementById('ai-check-countdown');
    if (txt) {
      if (engineRunning === true) txt.textContent = 'Engine: Running';
      else if (engineRunning === false) txt.textContent = 'Engine: Stopped';
      else txt.textContent = 'Engine: —';
    }
    if (dot) {
      dot.style.background = engineRunning === true ? 'var(--bs-success)' : (engineRunning === false ? '#dc3545' : 'var(--bs-secondary)');
    }
    if (scanEl) {
      const staleStatus = !lastStatusSyncMs || (Date.now() - lastStatusSyncMs > 90000);
      if (staleStatus) {
        scanEl.textContent = 'Next engine scan: —';
      } else
      if (engineNextScanSecs != null) {
        if (engineNextScanSecs < 0) {
          scanEl.innerHTML = '<span class="text-danger">Overdue: ' + Math.abs(engineNextScanSecs) + 's</span>';
        } else {
          scanEl.textContent = 'Next engine scan: ' + engineNextScanSecs + 's';
        }
      } else {
        scanEl.textContent = 'Next engine scan: —';
      }
    }
    if (aiEl) {
      const staleStatus = !lastStatusSyncMs || (Date.now() - lastStatusSyncMs > 90000);
      if (staleStatus) {
        aiEl.textContent = 'Next AI check: —';
        return;
      }
      var aiSecs = nextAiCheckDisplaySecs != null ? nextAiCheckDisplaySecs : nextAiCheckSecs;
      if (aiSecs != null) {
        if (aiSecs < 0) {
          aiEl.innerHTML = '<span class="text-danger">Next AI check: Overdue ' + Math.abs(aiSecs) + 's</span>';
      } else {
          if (aiSecs >= 60) {
            var m = Math.floor(aiSecs / 60);
            var s = aiSecs % 60;
            aiEl.textContent = 'Next AI check: ' + m + 'm ' + s + 's';
          } else {
            aiEl.textContent = 'Next AI check: ' + aiSecs + 's';
          }
        }
      } else {
        aiEl.textContent = 'Next AI check: —';
      }
    }
    updateLiveEntryWindowBadge();
  }

  function statusBadge(status) {
    if (status === 'OPEN') return '<span class="badge bg-warning text-dark">OPEN</span>';
    if (status === 'Waiting to enter') return '<span class="badge bg-info text-dark">Waiting to enter</span>';
    if (status === 'Placing…') return '<span class="badge bg-info text-dark">Placing…</span>';
    return '<span class="badge bg-secondary">CLOSED</span>';
  }

  function pnlClass(pnl) {
    if (pnl == null || pnl === '') return '';
    if (typeof pnl === 'number') return pnl < 0 ? 'text-danger' : (pnl > 0 ? 'text-success' : '');
    if (typeof pnl === 'string' && pnl !== '—' && pnl.startsWith('-')) return 'text-danger';
    if (typeof pnl === 'string' && pnl !== '—' && pnl.length) return 'text-success';
    return '';
  }

  function rowToBacktest(r) {
    const statusHtml = r.status_badge || statusBadge(r.status);
    const grossClass = r.gross_pnl_class != null ? r.gross_pnl_class : pnlClass(r.gross_pnl_raw);
    const netClass = r.net_pnl_class != null ? r.net_pnl_class : pnlClass(r.net_pnl_raw);
    const cappedClass = r.risk_capped_pnl_class != null ? r.risk_capped_pnl_class : pnlClass(r.risk_capped_pnl_raw);
    const qtyCell = (r.qty_display != null && r.qty_display !== '') ? r.qty_display : r.qty;
    return `
      <tr>
        <td>${r.date}</td>
        <td>${r.ce_pe}</td>
        <td>${r.strike}</td>
        <td>${r.strategy}</td>
        <td>${r.entry_time}</td>
        <td>${r.exit_time}</td>
        <td>${r.entry_price}</td>
        <td>${r.exit_price}</td>
        <td>${r.current_price}</td>
        <td>${qtyCell}</td>
        <td>${r.price_per_lot}</td>
        <td>${r.capital_used}</td>
        <td>${r.balance_left}</td>
        <td class="${grossClass}">${r.gross_pnl}</td>
        <td>${r.charges}</td>
        <td class="${netClass}">${r.net_pnl}</td>
        <td class="${cappedClass}">${r.risk_capped_pnl}</td>
        <td>${statusHtml}</td>
        <td>${r.exit_reason}</td>
      </tr>
    `;
  }

  function buildRowsForMode(mode, closedTrades, openSessions, waitingCount, allActiveSessions, brokerOrders, livePositions) {
    const rows = [];

    function formatLots(qty, lotSize) {
      const q = Number(qty);
      const ls = Number(lotSize);
      if (!isFinite(q) || q <= 0 || !isFinite(ls) || ls <= 0) return null;
      const lots = q / ls;
      if (!isFinite(lots) || lots <= 0) return null;
      // Only render lots when quantity is a valid full-lot multiple.
      // Legacy rows may contain non-multiple qty (older paper simulator behavior).
      if (!Number.isInteger(lots)) return null;
      const lotsStr = String(lots);
      return `${lotsStr} lot${lots === 1 ? '' : 's'} (${q})`;
    }
    function toNum(v) {
      const n = Number(v);
      return isFinite(n) ? n : null;
    }
    function round2(v) {
      return Math.round((v + Number.EPSILON) * 100) / 100;
    }

    // Normalize legacy balance values per session for closed rows.
    // Some older records can be inconsistent; we derive a stable running balance
    // from net P&L when possible.
    const bySession = {};
    (closedTrades || []).forEach(t => {
      const sid = t.session_id || t.sessionId || '__NO_SESSION__';
      if (!bySession[sid]) bySession[sid] = [];
      bySession[sid].push(t);
    });
    Object.values(bySession).forEach(group => {
      group.sort((a, b) => String(a.entry_time || '').localeCompare(String(b.entry_time || '')));
      let runningBalance = null;
      group.forEach((t, idx) => {
        const net = toNum(t.net_pnl != null ? t.net_pnl : t.pnl);
        let bal = toNum(t.balance_left);
        if (idx === 0) {
          if (bal != null) runningBalance = bal;
          t._computed_balance_left = bal;
          return;
        }
        if (runningBalance != null && net != null) {
          const expected = round2(runningBalance + net);
          if (bal == null || Math.abs(bal - expected) > 1.5) {
            bal = expected;
          }
          runningBalance = bal;
          t._computed_balance_left = bal;
          return;
        }
        if (bal != null) runningBalance = bal;
        t._computed_balance_left = bal;
      });
    });
    
    // LIVE table should mirror broker "Positions" view (symbol-wise rows + day P&L).
    if (mode === 'LIVE') {
      const positions = Array.isArray(livePositions) ? livePositions : [];
      positions.forEach(p => {
        const symbol = String(p.symbol || '');
        const cepe = symbol.endsWith('CE') ? 'CE' : (symbol.endsWith('PE') ? 'PE' : '—');
        const strikeMatch = symbol.match(/(\d+)(CE|PE)$/);
        const strike = strikeMatch ? strikeMatch[1] : '—';
        const netQty = Number(p.quantity || 0) || 0;
        const buyQty = Number(p.buy_quantity || 0) || 0;
        const sellQty = Number(p.sell_quantity || 0) || 0;
        const tradedQty = Math.max(Math.abs(buyQty), Math.abs(sellQty), Math.abs(netQty));
        const pnl = Number(p.pnl || 0) || 0;
        const buyAvg = p.buy_avg_price != null ? Number(p.buy_avg_price) : null;
        const sellAvg = p.sell_avg_price != null ? Number(p.sell_avg_price) : null;
        const last = p.last_price != null ? Number(p.last_price) : null;
        rows.push({
          date: new Date().toISOString().slice(0, 10),
          ce_pe: cepe,
          strike: strike,
          strategy: 'Broker Position',
          entry_time: '—',
          exit_time: '—',
          entry_price: (buyAvg != null && buyAvg > 0) ? fmtNum(buyAvg) : '—',
          exit_price: (sellAvg != null && sellAvg > 0) ? fmtNum(sellAvg) : '—',
          current_price: (last != null && last > 0) ? fmtNum(last) : '—',
          qty: netQty !== 0 ? netQty : (tradedQty || '—'),
          qty_display: netQty !== 0 ? netQty : (tradedQty || '—'),
          price_per_lot: '—',
          capital_used: '—',
          balance_left: '—',
          gross_pnl: pnl >= 0 ? fmtNum(pnl) : '-' + fmtNum(Math.abs(pnl)),
          charges: '—',
          net_pnl: pnl >= 0 ? fmtNum(pnl) : '-' + fmtNum(Math.abs(pnl)),
          risk_capped_pnl: pnl >= 0 ? fmtNum(pnl) : '-' + fmtNum(Math.abs(pnl)),
          gross_pnl_raw: pnl,
          net_pnl_raw: pnl,
          risk_capped_pnl_raw: pnl,
          exit_reason: '—',
          status_badge: netQty !== 0
            ? '<span class="badge bg-warning text-dark">OPEN</span>'
            : '<span class="badge bg-secondary">CLOSED</span>',
          sort_priority: 2,
          sort_ts: Number(new Date())
        });
      });
      rows.sort((a, b) => Number(a.net_pnl_raw || 0) - Number(b.net_pnl_raw || 0));
      return rows;
    }
    
    // Add sessions waiting to enter (no current_trade yet)
    allActiveSessions.forEach(s => {
      const sessionMode = (s.execution_mode || s.mode || '').toUpperCase();
      if (sessionMode !== mode) return;
      if (s.current_trade) return; // Skip - will be handled by openSessions below
      
      const rec = s.recommendation || {};
      const recPremium = rec.premium != null ? Number(rec.premium) : null;
      const recLotSize = rec.lotSize || rec.lot_size || '—';
      const recLots = rec.positionSizeLots || rec.position_size_lots || null;
      const waitingQtyDisplay = (recLots != null && recLotSize !== '—')
        ? `${recLots} lot${Number(recLots) === 1 ? '' : 's'}`
        : String(recLotSize);
      rows.push({
        date: new Date().toISOString().split('T')[0],
        ce_pe: rec.optionType || rec.ce_pe || rec.direction || '—',
        strike: rec.strike != null ? rec.strike : '—',
        strategy: rec.strategyName || rec.strategy || '—',
        entry_time: '—',
        exit_time: '—',
        entry_price: recPremium != null && !isNaN(recPremium) ? fmtNum(recPremium) : '—',
        exit_price: '—',
        current_price: recPremium != null && !isNaN(recPremium) ? fmtNum(recPremium) : '—',
        qty: recLotSize,
        qty_display: waitingQtyDisplay,
        price_per_lot: '—',
        capital_used: '—',
        balance_left: s.virtual_balance != null ? fmtNum(s.virtual_balance) : '—',
        gross_pnl: '—',
        charges: '—',
        net_pnl: '—',
        risk_capped_pnl: '—',
        gross_pnl_raw: null,
        net_pnl_raw: null,
        risk_capped_pnl_raw: null,
        exit_reason: '—',
        status_badge: '<span class="badge bg-info text-dark">Waiting to enter</span>',
        sort_priority: 3,
        sort_ts: Number(new Date(s.createdAt || Date.now()))
      });
    });
    
    // Add open trades
    openSessions.forEach(s => {
      const t = s.current_trade;
      if (!t) return;
      
      const rec = s.recommendation || {};
      const entryPrice = t.entry_price;
      const qty = t.qty;
      const lotSize = s.lot_size || rec.lot_size || rec.lotSize || 25;
      const lotsDisplay = formatLots(qty, lotSize);
      const currentLtp = (s.current_ltp != null && s.current_ltp > 0) ? s.current_ltp : entryPrice;
      const side = (t.side || 'BUY').toUpperCase();
      
      let grossPnl = null;
      if (entryPrice != null && currentLtp != null && qty != null) {
        if (side === 'BUY') grossPnl = (currentLtp - entryPrice) * qty;
        else grossPnl = (entryPrice - currentLtp) * qty;
      }
      const maxLossPerTrade = Number(s.max_loss_per_trade != null ? s.max_loss_per_trade : (s.risk_amount_per_trade != null ? s.risk_amount_per_trade : 300));
      const normalizedMaxLoss = isNaN(maxLossPerTrade) ? 300 : Math.min(300, Math.max(1, maxLossPerTrade));
      const riskCappedOpenPnl = grossPnl != null ? Math.max(grossPnl, -normalizedMaxLoss) : null;
      
      rows.push({
        date: String(t.entry_time || '').slice(0, 10),
        ce_pe: rec.optionType || (rec.tradeType === 'CALL' ? 'CE' : 'PE') || '—',
        strike: rec.strike != null ? rec.strike : '—',
        strategy: t.strategy_name || rec.strategyName || '—',
        entry_time: formatTime(t.entry_time),
        exit_time: '—',
        entry_price: entryPrice != null ? fmtNum(entryPrice) : '—',
        exit_price: '—',
        current_price: currentLtp != null ? fmtNum(currentLtp) : '—',
        qty: qty || 0,
        qty_display: lotsDisplay || (qty || 0),
        price_per_lot: entryPrice != null && lotSize ? fmtNum(entryPrice * lotSize) : '—',
        capital_used: entryPrice != null && qty ? fmtNum(entryPrice * qty) : '—',
        balance_left: s.virtual_balance != null ? fmtNum(s.virtual_balance) : '—',
        gross_pnl: grossPnl != null ? (grossPnl >= 0 ? fmtNum(grossPnl) : '-' + fmtNum(Math.abs(grossPnl))) : '—',
        charges: '—',
        net_pnl: grossPnl != null ? (grossPnl >= 0 ? fmtNum(grossPnl) : '-' + fmtNum(Math.abs(grossPnl))) : '—',
        risk_capped_pnl: riskCappedOpenPnl != null ? (riskCappedOpenPnl >= 0 ? fmtNum(riskCappedOpenPnl) : '-' + fmtNum(Math.abs(riskCappedOpenPnl))) : '—',
        gross_pnl_raw: grossPnl,
        net_pnl_raw: grossPnl,
        risk_capped_pnl_raw: riskCappedOpenPnl,
        exit_reason: '—',
        status_badge: '<span class="badge bg-warning text-dark">OPEN</span>',
        sort_priority: 2,
        sort_ts: Number(new Date(t.entry_time || s.createdAt || Date.now()))
      });
    });
    
    // Add closed trades
    closedTrades.forEach(t => {
      const entryPrice = t.entry_price;
      const exitPrice = t.exit_price;
      const qty = t.qty || 0;
      const charges = t.charges != null ? Number(t.charges) : null;
      const netPnl = t.net_pnl != null ? Number(t.net_pnl) : (t.pnl != null ? Number(t.pnl) : null);
      const riskCappedPnl = t.risk_capped_pnl != null ? Number(t.risk_capped_pnl) : netPnl;
      let grossPnl = t.gross_pnl != null ? Number(t.gross_pnl) : null;
      // Backward compatibility: older records may have gross_pnl copied from net pnl.
      if (grossPnl == null && netPnl != null && charges != null) {
        grossPnl = netPnl + charges;
      } else if (
        grossPnl != null && netPnl != null && charges != null &&
        Math.abs(grossPnl - netPnl) < 0.01 && Math.abs(charges) > 0.01
      ) {
        grossPnl = netPnl + charges;
      }
      const parsedLotSize = t.lot_size != null ? Number(t.lot_size) : null;
      const inferredLotSize = (!parsedLotSize && qty)
        ? ((Number(qty) % 25 === 0) ? 25 : ((Number(qty) % 15 === 0) ? 15 : null))
        : null;
      const lotSize = parsedLotSize || inferredLotSize;
      const lotsDisplay = formatLots(qty, lotSize);
      const pricePerLot = t.price_per_lot != null
        ? Number(t.price_per_lot)
        : ((entryPrice != null && lotSize) ? (Number(entryPrice) * lotSize) : null);
      const capitalUsed = t.capital_used != null
        ? Number(t.capital_used)
        : ((entryPrice != null && qty != null) ? (Number(entryPrice) * Number(qty)) : null);
      rows.push({
        date: formatDate(t.entry_time),
        ce_pe: t.option_type || '—',
        strike: t.strike != null ? t.strike : '—',
        strategy: t.strategy || '—',
        entry_time: formatTime(t.entry_time),
        exit_time: formatTime(t.exit_time),
        entry_price: fmtNum(entryPrice),
        exit_price: fmtNum(exitPrice),
        current_price: '—',
        qty: qty,
        qty_display: lotsDisplay || qty,
        price_per_lot: pricePerLot != null && !isNaN(pricePerLot) ? fmtNum(pricePerLot) : '—',
        capital_used: capitalUsed != null && !isNaN(capitalUsed) ? fmtNum(capitalUsed) : '—',
        balance_left: t._computed_balance_left != null ? fmtNum(t._computed_balance_left) : (t.balance_left != null ? fmtNum(t.balance_left) : '—'),
        gross_pnl: grossPnl != null ? (grossPnl >= 0 ? fmtNum(grossPnl) : '-' + fmtNum(Math.abs(grossPnl))) : '—',
        charges: charges != null ? fmtNum(charges) : '—',
        net_pnl: netPnl != null ? (netPnl >= 0 ? fmtNum(netPnl) : '-' + fmtNum(Math.abs(netPnl))) : '—',
        risk_capped_pnl: riskCappedPnl != null ? (riskCappedPnl >= 0 ? fmtNum(riskCappedPnl) : '-' + fmtNum(Math.abs(riskCappedPnl))) : '—',
        gross_pnl_raw: grossPnl,
        net_pnl_raw: netPnl,
        risk_capped_pnl_raw: riskCappedPnl,
        exit_reason: t.exit_reason || '—',
        status_badge: '<span class="badge bg-secondary">CLOSED</span>',
        sort_priority: 1,
        sort_ts: Number(new Date(t.entry_time || t.exit_time || Date.now()))
      });
    });
    
    rows.sort((a, b) => {
      const aPriority = Number(a.sort_priority || 0);
      const bPriority = Number(b.sort_priority || 0);
      if (bPriority !== aPriority) return bPriority - aPriority;
      const aTs = Number(a.sort_ts || 0);
      const bTs = Number(b.sort_ts || 0);
      return bTs - aTs;
    });
    return rows;
  }

  function renderModeExecutions(mode, closedTrades, openSessions, waitingCount, activeSessions, brokerOrders, livePositions) {
    const isPaper = mode === 'PAPER';
    const tbody = document.getElementById(isPaper ? 'paper-executions-tbody' : 'live-executions-tbody');
    const countEl = document.getElementById(isPaper ? 'paper-executions-count' : 'live-executions-count');
    const waitingEl = document.getElementById(isPaper ? 'paper-sessions-waiting-msg' : 'live-sessions-waiting-msg');
    const prefix = isPaper ? 'Paper' : 'Live';
    if (waitingEl) {
      if (isPaper) {
      waitingEl.style.display = waitingCount > 0 ? 'block' : 'none';
      waitingEl.textContent = waitingCount + ' ' + prefix.toLowerCase() + ' session(s) active — engine will place trade when conditions are met.';
      } else {
        waitingEl.style.display = 'none';
    }
    }
    const rows = buildRowsForMode(mode, closedTrades, openSessions, waitingCount, activeSessions, brokerOrders, livePositions);
    if (isPaper) {
      activePaperSessionId = (activeSessions.length > 0 && (activeSessions[0].sessionId || activeSessions[0].session_id)) || null;
      const stopBtn = document.getElementById('paper-stop-btn');
      if (stopBtn) stopBtn.style.display = activePaperSessionId ? '' : 'none';
    } else {
      activeLiveSessionId = (activeSessions.length > 0 && (activeSessions[0].sessionId || activeSessions[0].session_id)) || null;
      const stopBtn = document.getElementById('live-stop-btn');
      if (stopBtn) stopBtn.style.display = activeLiveSessionId ? '' : 'none';
    }
    countEl.textContent = rows.length;
    if (!isPaper) {
      const pnlEl = document.getElementById('live-positions-total-pnl');
      if (pnlEl) {
        const total = (Array.isArray(livePositions) ? livePositions : []).reduce((acc, p) => {
          const n = Number((p || {}).pnl);
          return acc + (isNaN(n) ? 0 : n);
        }, 0);
        pnlEl.textContent = 'Total P&L ' + fmtNum(total);
        pnlEl.classList.remove('text-success', 'text-danger', 'text-light');
        pnlEl.classList.add(total < 0 ? 'text-danger' : (total > 0 ? 'text-success' : 'text-light'));
      }
    }
    if (rows.length === 0) {
      tbody.innerHTML = '<tr><td colspan="20" class="text-center text-muted py-4">No ' + prefix.toLowerCase() + ' trades today.</td></tr>';
      return;
    }
    tbody.innerHTML = rows.map(rowToBacktest).join('');
  }

  function startCountdown() {
    if (countdownTimer) clearInterval(countdownTimer);
    dataRefreshSecs = 60;
    function tick() {
      if (dataRefreshSecs > 0) dataRefreshSecs--; else { runRefresh(); }
      
      if (typeof engineNextScanSecs === 'number') {
        engineNextScanSecs--;
        // Trigger refresh when we exactly hit 0 to sync with expected engine tick
        if (engineNextScanSecs === 0) runRefresh();
      }
      
      if (typeof nextAiCheckSecs === 'number' && nextAiCheckSecs > 0) nextAiCheckSecs--;
      if (typeof nextAiCheckDisplaySecs === 'number') {
        nextAiCheckDisplaySecs--;
        if (nextAiCheckDisplaySecs < 0) nextAiCheckDisplaySecs = 60;
      } else if (nextAiCheckSecs != null && nextAiCheckSecs >= 0) {
        nextAiCheckDisplaySecs = nextAiCheckSecs;
      }
      updateEngineStatusUI();
    }
    tick();
    countdownTimer = setInterval(tick, 1000);
  }

  document.getElementById('investment-amount').addEventListener('input', fetchRiskConfig);
  document.getElementById('investment-amount').addEventListener('change', fetchRiskConfig);
  document.getElementById('paper-risk-amount').addEventListener('input', fetchRiskConfig);
  document.getElementById('paper-risk-amount').addEventListener('change', fetchRiskConfig);

  document.getElementById('paper-enable-ai-switching').addEventListener('change', function() {
    var strategySelect = document.getElementById('paper-strategy');
    strategySelect.disabled = this.checked;
    if (this.checked) strategySelect.value = 'AI_AUTO';
  });

  function stopSession(sessionId, statusElId, label, btn) {
    if (!sessionId) return;
    if (btn) btn.disabled = true;
    fetch('/api/trade-sessions/' + encodeURIComponent(sessionId) + '/kill', { method: 'POST' })
      .then(r => r.json())
      .then(data => {
        const el = document.getElementById(statusElId);
        if (el) el.innerHTML = data.ok ? '<span class="text-success">' + label + ' stopped.</span>' : '<span class="text-danger">' + (data.error || 'Failed to stop') + '</span>';
        if (data.ok) runRefresh();
      })
      .catch(() => {
        const el = document.getElementById(statusElId);
        if (el) el.innerHTML = '<span class="text-danger">Request failed</span>';
      })
      .finally(() => { if (btn) btn.disabled = false; });
  }

  function resetCooldownFromBadge(btn) {
    const sessionId = (btn && btn.dataset && btn.dataset.sessionId) ? btn.dataset.sessionId : null;
    if (!sessionId) return;
    btn.style.pointerEvents = 'none';
    fetch('/api/trade-sessions/' + encodeURIComponent(sessionId) + '/cooldown-reset', { method: 'POST' })
      .then(r => r.json())
      .then(data => {
        const el = document.getElementById('paper-trade-status');
        if (el) {
          if (data && data.ok) el.innerHTML = '<span class="text-success">Cooldown reset successfully.</span>';
          else el.innerHTML = '<span class="text-danger">' + ((data && data.error) || 'Failed to reset cooldown') + '</span>';
        }
        runRefresh();
      })
      .catch(() => {
        const el = document.getElementById('paper-trade-status');
        if (el) el.innerHTML = '<span class="text-danger">Cooldown reset request failed</span>';
      })
      .finally(() => { btn.style.pointerEvents = ''; });
  }

  const liveStopBtn = document.getElementById('live-stop-btn');
  if (liveStopBtn) {
    liveStopBtn.addEventListener('click', function() {
      stopSession(activeLiveSessionId, 'paper-trade-status', 'Live', this);
    });
  }
  const cooldownBadge = document.getElementById('cooldown-active-badge');
  if (cooldownBadge) {
    cooldownBadge.addEventListener('click', function() {
      resetCooldownFromBadge(this);
    });
  }
  const thresholdSaveBtn = document.getElementById('entry-threshold-save-btn');
  if (thresholdSaveBtn) {
    thresholdSaveBtn.addEventListener('click', function() {
      saveEntryThreshold();
    });
  }

  document.getElementById('paper-trade-btn').addEventListener('click', function() {
    const btn = this;
    const status = document.getElementById('paper-trade-status');
    const instrument = document.getElementById('paper-instrument').value;
    const investmentAmount = parseFloat(document.getElementById('investment-amount').value) || 10000;
    const riskAmount = parseFloat(document.getElementById('paper-risk-amount').value) || 300;
    const dailyLossLimit = parseFloat(document.getElementById('paper-daily-loss-limit').value) || 3000;
    const mode = 'LIVE';
    const today = new Date().toISOString().slice(0, 10);
    btn.disabled = true;
    status.innerHTML = '<span class="text-primary">Starting session...</span>';
    const aiEnabled = document.getElementById('paper-enable-ai-switching') && document.getElementById('paper-enable-ai-switching').checked;
    const apiUrl = '/api/live-trade/execute';
    fetch(apiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        instrument: instrument,
        investment_amount: investmentAmount,
        risk_amount_per_trade: riskAmount,
        daily_loss_limit: dailyLossLimit,
        ai_auto_switching_enabled: aiEnabled
      })
    })
      .then(r => r.json())
      .then(data => {
        if (data.ok) {
          status.innerHTML = '<span class="text-success">' + (data.message || 'Session started.') + '</span>';
          var rec = data.recommendation || {};
          var premium = rec.premium != null ? Number(rec.premium) : null;
          var lotSize = rec.lot_size != null ? Number(rec.lot_size) : 25;
          var balance = data.virtual_balance != null ? Number(data.virtual_balance) : null;
          var now = new Date();
          var timeStr = now.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
          var dateStr = now.toISOString().slice(0, 10);
          optimisticRows.push({
            mode: mode,
            date: dateStr,
            ce_pe: rec.optionType || '—',
            strike: rec.strike != null ? rec.strike : '—',
            strategy: rec.strategyName || '—',
            entry_time: timeStr,
            entry_price: premium != null ? fmtNum(premium) : '—',
            price_per_lot: premium != null && lotSize ? fmtNum(premium * lotSize) : '—',
            qty: '—',
            capital_used: '—',
            balance_left: balance != null ? fmtNum(balance) : '—',
            exit_reason: '—',
            status: 'Waiting to enter'
          });
          fetchExecutions();
        } else {
          status.innerHTML = '<span class="text-danger">' + (data.error || 'Failed') + '</span>';
        }
      })
      .catch(err => {
        status.innerHTML = '<span class="text-danger">Request failed</span>';
        fetchExecutions();
      })
      .finally(() => { btn.disabled = false; });
  });

  fetchRiskConfig();
  fetchEntryThreshold();
  fetchBalance();
  fetchEngineStatus();
  fetchExecutions();
  setInterval(fetchEngineStatus, 15000);
  startCountdown();
})();
</script>
{% endblock %}
