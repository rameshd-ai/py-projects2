{% extends "base_dashboard.html" %}
{% block content %}
<div class="fade-in">
  <div class="alert alert-info border-0 mb-4" style="background: rgba(168, 199, 250, 0.12);">
    <div class="d-flex align-items-start gap-2">
      <span class="material-icons-round text-primary">edit_note</span>
      <div>
        <strong>Paper &amp; Live Trading (NIFTY / BANKNIFTY):</strong>
        <ul class="mb-0 mt-2 small">
          <li>One page for both: switch between <strong>Paper money</strong> (no real orders) and <strong>Real money</strong> (live Zerodha orders). Same engine as Backtest.</li>
          <li>Engine, table and AI refresh every 1 minute (no conflict).</li>
          <li>Select money mode, index, capital, and click Trade to place an order.</li>
          <li><strong>P&L:</strong> Unrealized P&L updates with price. When stop is hit, loss is capped at ₹300 per trade (same as backtest).</li>
          <li><strong>Refresh:</strong> Active sessions are saved on the server; refreshing the page does not stop them.</li>
        </ul>
      </div>
    </div>
  </div>

  <!-- AI & Strategy (same as Backtest) -->
  <div class="card mb-4">
    <div class="card-header d-flex align-items-center justify-content-between">
      <div class="d-flex align-items-center gap-2">
        <span class="material-icons-round text-primary-custom">smart_toy</span>
        AI &amp; Strategy
      </div>
      <div class="form-check form-switch mb-0">
        <input class="form-check-input" type="checkbox" id="paper-enable-ai-switching" checked>
        <label class="form-check-label" for="paper-enable-ai-switching">Enable AI Auto-Switching</label>
      </div>
    </div>
    <div class="card-body">
      <div class="row g-3">
        <div class="col-md-4">
          <label class="form-label small">Strategy (disabled when AI ON)</label>
          <select class="form-select form-select-sm" id="paper-strategy" disabled>
            <option value="AI_AUTO">AI Auto-Select</option>
            <option value="Index Momentum">Index Momentum</option>
            <option value="Momentum Breakout">Momentum Breakout</option>
            <option value="VWAP Trend Ride">VWAP Trend Ride</option>
            <option value="RSI Reversal Fade">RSI Reversal Fade</option>
            <option value="Opening Range Breakout">Opening Range Breakout</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <div class="row g-3 mb-4">
    <div class="col-12 col-md-6 col-lg-3">
      <div class="card h-100">
        <div class="card-header d-flex align-items-center gap-2">
          <span class="material-icons-round text-primary-custom">account_balance</span>
          Zerodha Balance
        </div>
        <div class="card-body">
          <div class="d-flex align-items-baseline gap-2">
            <span class="metric-value" id="zerodha-balance">—</span>
            <span class="text-muted small" id="zerodha-balance-status"></span>
          </div>
          <p class="text-muted small mb-0 mt-1">Before investment (live)</p>
        </div>
      </div>
    </div>
    <div class="col-12 col-md-6 col-lg-3">
      <div class="card h-100">
        <div class="card-header d-flex align-items-center gap-2">
          <span class="material-icons-round text-primary-custom">savings</span>
          Investment Amount
        </div>
        <div class="card-body">
          <input type="number" class="form-control" id="investment-amount" value="10000" min="1000" step="5000" placeholder="e.g. 10000">
          <p class="text-muted small mb-0 mt-1">Capital for today</p>
        </div>
      </div>
    </div>
    <div class="col-12 col-md-6 col-lg-3">
      <div class="card h-100">
        <div class="card-header d-flex align-items-center gap-2">
          <span class="material-icons-round text-primary-custom">shield</span>
          Risk Limits
        </div>
        <div class="card-body">
          <div class="mb-2">
            <label class="form-label small mb-1">Risk Per Trade (Value)</label>
            <input type="number" class="form-control form-control-sm" id="paper-risk-amount" value="300" min="1" step="50" placeholder="300">
          </div>
          <div class="mb-0">
            <label class="form-label small mb-1">Daily Loss Limit (Value)</label>
            <input type="number" class="form-control form-control-sm" id="paper-daily-loss-limit" value="3000" min="1" step="100" placeholder="3000">
          </div>
        </div>
      </div>
    </div>
    <div class="col-12 col-md-6 col-lg-3">
      <div class="card h-100">
        <div class="card-header d-flex align-items-center gap-2">
          <span class="material-icons-round text-primary-custom">candlestick_chart</span>
          Instrument &amp; Trade
        </div>
        <div class="card-body">
          <div class="mb-2">
            <label class="form-label small mb-1">Money mode</label>
            <select class="form-select form-select-sm" id="money-mode">
              <option value="PAPER">Paper money (no real orders)</option>
              <option value="LIVE">Real money (live Zerodha orders)</option>
            </select>
          </div>
          <div class="mb-2">
            <label class="form-label small mb-1">Index</label>
            <select class="form-select" id="paper-instrument">
              <option value="NIFTY">NIFTY 50</option>
              <option value="BANKNIFTY">BANK NIFTY</option>
            </select>
          </div>
          <button type="button" class="btn btn-primary w-100 d-flex align-items-center justify-content-center gap-2" id="paper-trade-btn">
            <span class="material-icons-round">trending_up</span> Trade
          </button>
          <div id="paper-trade-status" class="mt-2 small"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="card mb-3">
    <div class="card-body py-2 px-3 d-flex flex-wrap align-items-center gap-3 gap-md-4">
      <span class="text-muted small d-flex align-items-center gap-1" id="engine-status-wrap">
        <span class="rounded-circle d-inline-block" id="engine-dot" style="width: 8px; height: 8px; background: var(--bs-secondary);"></span>
        <span id="engine-status-text">Engine: —</span>
      </span>
      <span class="text-muted small" id="engine-scan-countdown">Next engine scan: —</span>
      <span class="text-muted small" id="ai-check-countdown">Next AI check: —</span>
      <span class="badge bg-warning text-dark" id="cooldown-active-badge" style="display: none;"></span>
      <span class="text-muted small" id="session-active-badge" style="display: none;"></span>
    </div>
  </div>

  <div class="card mb-3">
    <div class="card-header d-flex align-items-center gap-2">
      <span class="material-icons-round text-primary-custom">summarize</span>
      Today Overall Status
    </div>
    <div class="card-body py-2 px-3 d-flex flex-wrap align-items-center gap-3 gap-md-4">
      <span class="badge bg-primary bg-opacity-10 text-primary-custom" id="overall-trades-count">0 trades</span>
      <span class="text-muted small">Paper Net: <span id="overall-paper-net">₹0.00</span></span>
      <span class="text-muted small">Live Net: <span id="overall-live-net">₹0.00</span></span>
      <span class="text-muted small">Total Net: <strong id="overall-total-net">₹0.00</strong></span>
    </div>
  </div>

  <!-- Paper trades (today) -->
  <div class="card mb-4">
    <div class="card-header d-flex align-items-center justify-content-between flex-wrap gap-2">
      <div class="d-flex align-items-center gap-2">
        <span class="material-icons-round text-primary-custom">edit_note</span>
        Paper trades (today)
      </div>
      <div class="d-flex align-items-center gap-2">
        <span class="badge bg-primary bg-opacity-10 text-primary-custom" id="paper-executions-count">0</span>
        <button type="button" class="btn btn-sm btn-outline-danger" id="paper-stop-btn" style="display: none;">
          <span class="material-icons-round" style="font-size: 1rem;">stop_circle</span> Stop Paper
        </button>
      </div>
    </div>
    <div id="paper-sessions-waiting-msg" class="alert alert-secondary border-0 mb-0 rounded-0 small py-2 px-3" style="display: none;"></div>
    <div class="card-body p-0">
      <div class="table-responsive overflow-x-auto" style="max-width: 100%; overflow-x: auto;">
        <table class="table table-sm table-dark table-hover mb-0" style="min-width: 1500px; white-space: nowrap;">
          <thead>
            <tr>
              <th>Date</th>
              <th>CE/PE</th>
              <th>Strike</th>
              <th>Strategy</th>
              <th>Entry Time</th>
              <th>Exit Time</th>
              <th>Entry Price</th>
              <th>Exit Price</th>
              <th>Current price</th>
              <th>Qty</th>
              <th>Price/Lot</th>
              <th>Capital Used</th>
              <th>Balance Left</th>
              <th>Gross P&L</th>
              <th>Charges</th>
              <th>Net P&L</th>
              <th>Risk-Capped P&L</th>
              <th>Status</th>
              <th>Exit Reason</th>
            </tr>
          </thead>
          <tbody id="paper-executions-tbody">
            <tr><td colspan="20" class="text-center text-muted py-4">No paper trades today.</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Live trades (today) -->
  <div class="card">
    <div class="card-header d-flex align-items-center justify-content-between flex-wrap gap-2">
      <div class="d-flex align-items-center gap-2">
        <span class="material-icons-round text-primary-custom">show_chart</span>
        Live trades (today)
      </div>
      <div class="d-flex align-items-center gap-2">
        <span class="badge bg-primary bg-opacity-10 text-primary-custom" id="live-executions-count">0</span>
        <span class="badge bg-secondary bg-opacity-25 text-light" id="live-positions-total-pnl">Total P&amp;L —</span>
        <button type="button" class="btn btn-sm btn-outline-danger" id="live-stop-btn" style="display: none;">
          <span class="material-icons-round" style="font-size: 1rem;">stop_circle</span> Stop Live
        </button>
      </div>
    </div>
    <div id="live-sessions-waiting-msg" class="alert alert-secondary border-0 mb-0 rounded-0 small py-2 px-3" style="display: none;"></div>
    <div class="card-body p-0">
      <div class="table-responsive overflow-x-auto" style="max-width: 100%; overflow-x: auto;">
        <table class="table table-sm table-dark table-hover mb-0" style="min-width: 1500px; white-space: nowrap;">
          <thead>
            <tr>
              <th>Date</th>
              <th>CE/PE</th>
              <th>Strike</th>
              <th>Strategy</th>
              <th>Entry Time</th>
              <th>Exit Time</th>
              <th>Entry Price</th>
              <th>Exit Price</th>
              <th>Current price</th>
              <th>Qty</th>
              <th>Price/Lot</th>
              <th>Capital Used</th>
              <th>Balance Left</th>
              <th>Gross P&L</th>
              <th>Charges</th>
              <th>Net P&L</th>
              <th>Risk-Capped P&L</th>
              <th>Status</th>
              <th>Exit Reason</th>
            </tr>
          </thead>
          <tbody id="live-executions-tbody">
            <tr><td colspan="20" class="text-center text-muted py-4">No live trades today.</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Today full history (executed + open) -->
  <div class="card mt-4">
    <div class="card-header d-flex align-items-center justify-content-between flex-wrap gap-2">
      <div class="d-flex align-items-center gap-2">
        <span class="material-icons-round text-primary-custom">history</span>
        Today full history (executed + open)
      </div>
      <span class="badge bg-primary bg-opacity-10 text-primary-custom" id="today-full-history-count">0</span>
    </div>
    <div class="card-body p-0">
      <div class="table-responsive overflow-x-auto" style="max-width: 100%; overflow-x: auto;">
        <table class="table table-sm table-dark table-hover mb-0" style="min-width: 1200px; white-space: nowrap;">
          <thead>
            <tr>
              <th>Time</th>
              <th>Mode</th>
              <th>Instrument</th>
              <th>Symbol</th>
              <th>Strategy</th>
              <th>Status</th>
              <th>Entry</th>
              <th>Exit</th>
              <th>Qty</th>
              <th>Gross P&amp;L</th>
              <th>Net P&amp;L</th>
              <th>Exit Reason</th>
            </tr>
          </thead>
          <tbody id="today-full-history-tbody">
            <tr><td colspan="12" class="text-center text-muted py-4">No today history.</td></tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</div>

{% endblock %}

{% block scripts %}
{{ super() }}
<script>
(function() {
  let dataRefreshSecs = 60;
  let countdownTimer = null;
  let optimisticRows = [];
  let activePaperSessionId = null;
  let activeLiveSessionId = null;
  let engineNextScanSecs = null;
  let nextAiCheckSecs = null;
  let nextAiCheckDisplaySecs = null;
  let engineRunning = true;
  let lastStatusSyncMs = 0;

  function getTradeMode() {
    return (document.getElementById('money-mode') && document.getElementById('money-mode').value) || 'PAPER';
  }

  function formatTime(iso) {
    if (!iso) return '—';
    try {
      const d = new Date(iso);
      return d.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    } catch (e) { return iso; }
  }
  function formatDate(iso) {
    if (!iso) return '—';
    try {
      return (iso + '').slice(0, 10);
    } catch (e) { return iso; }
  }
  function fmtNum(v) {
    if (v == null || v === '' || v === '—') return '—';
    const n = Number(v);
    if (isNaN(n)) return '—';
    return '₹' + n.toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  }

  function fetchRiskConfig() {
    const amt = parseFloat(document.getElementById('investment-amount').value) || 10000;
    const riskAmount = parseFloat(document.getElementById('paper-risk-amount').value) || 300;
    fetch('/api/paper-trade/risk-config?investment_amount=' + encodeURIComponent(amt) + '&risk_amount=' + encodeURIComponent(riskAmount))
      .then(r => r.json())
      .then(data => {
        const dailyInput = document.getElementById('paper-daily-loss-limit');
        if (dailyInput && (!dailyInput.value || Number(dailyInput.value) <= 0)) {
          dailyInput.value = data.daily_loss_limit != null ? Number(data.daily_loss_limit) : 3000;
        }
      })
      .catch(() => {});
  }

  function fetchBalance() {
    fetch('/api/account-balance?mode=LIVE')
      .then(r => r.json())
      .then(data => {
        const el = document.getElementById('zerodha-balance');
        const status = document.getElementById('zerodha-balance-status');
        if (data.balance != null) {
          el.textContent = '₹' + Number(data.balance).toLocaleString('en-IN', { minimumFractionDigits: 2 });
          status.textContent = data.mode || '';
        } else {
          el.textContent = '—';
          status.textContent = 'Not connected';
        }
      })
      .catch(() => {
        document.getElementById('zerodha-balance').textContent = '—';
        document.getElementById('zerodha-balance-status').textContent = 'Error';
      });
  }

  function runRefresh() {
    dataRefreshSecs = 60;
    fetchEngineStatus();
    fetchBalance();
    fetchExecutions();
  }

  function safeJson(r) {
    if (!r.ok) throw new Error('API ' + r.status);
    return r.json().catch(function() { throw new Error('Invalid JSON'); });
  }

  function fetchJsonWithTimeout(url, timeoutMs) {
    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), timeoutMs || 12000);
    return fetch(url, { signal: controller.signal })
      .then(safeJson)
      .finally(() => clearTimeout(timer));
  }

  function fetchEngineStatus() {
    return fetchJsonWithTimeout('/api/engine/status', 8000)
      .then(function(data) {
        if (!data || typeof data !== 'object') return;
        if (typeof data.running === 'boolean') {
          engineRunning = data.running;
        }
        if (typeof data.next_scan_in_seconds === 'number') {
          engineNextScanSecs = data.next_scan_in_seconds;
        } else if (typeof data.next_scan_sec === 'number') {
          engineNextScanSecs = data.next_scan_sec;
        }
        lastStatusSyncMs = Date.now();
        updateEngineStatusUI();
      })
      .catch(function() {
        // Keep last known engine status; avoid blanking UI on transient timeout.
      });
  }

  function fetchExecutions() {
    Promise.all([
      fetchJsonWithTimeout('/api/trade-history?mode=PAPER&today=1', 12000),
      fetchJsonWithTimeout('/api/trade-history?mode=LIVE&today=1', 12000),
      fetchJsonWithTimeout('/api/trade-sessions', 12000),
      fetchJsonWithTimeout('/api/live-executions-today?today=1', 12000),
      fetchJsonWithTimeout('/api/live-positions-today?exchange=NFO', 12000)
    ]).then(([paperData, liveData, sessionsData, brokerExecData, livePosData]) => {
      try {
        const paperTrades = (paperData && paperData.trades) ? paperData.trades : [];
        const liveTrades = (liveData && liveData.trades) ? liveData.trades : [];
        updateOverallStatus(paperTrades, liveTrades);
        const sessions = (sessionsData && sessionsData.sessions) ? sessionsData.sessions : [];
        var modeKey = function(s) { return (s.execution_mode || s.mode || '').toUpperCase(); };
        const paperOpen = sessions.filter(s => modeKey(s) === 'PAPER' && s.status === 'ACTIVE' && s.current_trade);
        const paperWaiting = sessions.filter(s => modeKey(s) === 'PAPER' && s.status === 'ACTIVE' && !s.current_trade);
        const paperActive = sessions.filter(s => modeKey(s) === 'PAPER' && s.status === 'ACTIVE');
        const liveOpen = sessions.filter(s => modeKey(s) === 'LIVE' && s.status === 'ACTIVE' && s.current_trade);
        const liveWaiting = sessions.filter(s => modeKey(s) === 'LIVE' && s.status === 'ACTIVE' && !s.current_trade);
        const liveActive = sessions.filter(s => modeKey(s) === 'LIVE' && s.status === 'ACTIVE');
        updateCooldownBadge(sessions);
        
        if (paperOpen.length > 0) optimisticRows = optimisticRows.filter(o => (o.mode || 'PAPER') !== 'PAPER');
        if (liveOpen.length > 0) optimisticRows = optimisticRows.filter(o => (o.mode || 'PAPER') !== 'LIVE');
        if (sessionsData != null) {
          engineRunning = sessionsData.engine_running !== false;
          engineNextScanSecs = typeof sessionsData.next_scan === 'number' ? sessionsData.next_scan : null;
          var raw = sessionsData.next_ai_check_secs;
          nextAiCheckSecs = (typeof raw === 'number' && !isNaN(raw)) ? raw : null;
          if (nextAiCheckSecs == null && (paperActive.length > 0 || liveActive.length > 0)) {
            nextAiCheckSecs = 60;
          }
          if (nextAiCheckSecs != null && nextAiCheckSecs >= 0) nextAiCheckDisplaySecs = nextAiCheckSecs;
          lastStatusSyncMs = Date.now();
        }
        updateEngineStatusUI();
        var paperActiveCount = paperActive.length;
        var liveActiveCount = liveActive.length;
        var badgeEl = document.getElementById('session-active-badge');
        if (badgeEl) {
          if (paperActiveCount > 0 && liveActiveCount > 0) {
            badgeEl.style.display = '';
            badgeEl.textContent = paperActiveCount + ' Paper, ' + liveActiveCount + ' Live session(s) active';
          } else if (paperActiveCount > 0) {
            badgeEl.style.display = '';
            badgeEl.textContent = paperActiveCount + ' Paper session(s) active';
          } else if (liveActiveCount > 0) {
            badgeEl.style.display = '';
            badgeEl.textContent = liveActiveCount + ' Live session(s) active';
          } else {
            badgeEl.style.display = 'none';
          }
        }
        const brokerOrders = (brokerExecData && brokerExecData.orders) ? brokerExecData.orders : [];
        const livePositions = (livePosData && livePosData.positions) ? livePosData.positions : [];
        renderModeExecutions('PAPER', paperTrades, paperOpen, paperWaiting.length, paperActive, null, null);
        renderModeExecutions('LIVE', liveTrades, liveOpen, liveWaiting.length, liveActive, brokerOrders, livePositions);
        renderTodayFullHistory(paperTrades, liveTrades, paperOpen, liveOpen, paperWaiting, liveWaiting, brokerOrders);
      } catch (e) {
        // Keep last-rendered table if parsing fails; avoid "vanishing" active sessions.
      }
    }).catch(function() {
      // Keep last-rendered table and last-known engine status while reconnecting.
      fetchEngineStatus();
    });
  }

  function updateCooldownBadge(sessions) {
    const badge = document.getElementById('cooldown-active-badge');
    if (!badge) return;
    const now = new Date();
    let nearest = null;
    let nearestMode = null;
    let nearestSessionId = null;
    (sessions || []).forEach(s => {
      if ((s.status || '').toUpperCase() !== 'ACTIVE') return;
      if (!s.cooldown_until) return;
      const dt = new Date(s.cooldown_until);
      if (isNaN(dt.getTime())) return;
      if (dt <= now) return;
      if (!nearest || dt < nearest) {
        nearest = dt;
        nearestMode = ((s.execution_mode || s.mode || '') + '').toUpperCase() || 'SESSION';
        nearestSessionId = s.sessionId || s.session_id || null;
      }
    });
    if (!nearest) {
      badge.style.display = 'none';
      badge.dataset.sessionId = '';
      badge.style.cursor = '';
      badge.title = '';
      return;
    }
    const t = nearest.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' });
    badge.textContent = `${nearestMode} COOLDOWN ACTIVE until ${t} (Click to reset)`;
    badge.style.display = '';
    badge.dataset.sessionId = nearestSessionId || '';
    badge.style.cursor = nearestSessionId ? 'pointer' : '';
    badge.title = nearestSessionId ? 'Click to reset cooldown now' : '';
  }

  function sumNetPnl(trades) {
    if (!Array.isArray(trades)) return 0;
    return trades.reduce((acc, t) => {
      const net = t && t.net_pnl != null ? Number(t.net_pnl) : (t && t.pnl != null ? Number(t.pnl) : 0);
      return acc + (isNaN(net) ? 0 : net);
    }, 0);
  }

  function applyPnlColor(el, value) {
    if (!el) return;
    el.classList.remove('text-success', 'text-danger');
    if (value > 0) el.classList.add('text-success');
    else if (value < 0) el.classList.add('text-danger');
  }

  function updateOverallStatus(paperTrades, liveTrades) {
    const paperNet = sumNetPnl(paperTrades);
    const liveNet = sumNetPnl(liveTrades);
    const totalNet = paperNet + liveNet;
    const tradesCount = (Array.isArray(paperTrades) ? paperTrades.length : 0) + (Array.isArray(liveTrades) ? liveTrades.length : 0);

    const countEl = document.getElementById('overall-trades-count');
    const paperEl = document.getElementById('overall-paper-net');
    const liveEl = document.getElementById('overall-live-net');
    const totalEl = document.getElementById('overall-total-net');

    if (countEl) countEl.textContent = `${tradesCount} trade${tradesCount === 1 ? '' : 's'}`;
    if (paperEl) {
      paperEl.textContent = fmtNum(paperNet);
      applyPnlColor(paperEl, paperNet);
    }
    if (liveEl) {
      liveEl.textContent = fmtNum(liveNet);
      applyPnlColor(liveEl, liveNet);
    }
    if (totalEl) {
      totalEl.textContent = fmtNum(totalNet);
      applyPnlColor(totalEl, totalNet);
    }
  }

  function renderTodayFullHistory(paperTrades, liveTrades, paperOpen, liveOpen, paperWaiting, liveWaiting, brokerOrders) {
    const tbody = document.getElementById('today-full-history-tbody');
    const countEl = document.getElementById('today-full-history-count');
    if (!tbody || !countEl) return;

    function esc(v) {
      return String(v == null ? '' : v).replace(/&/g, '&amp;').replace(/</g, '&lt;');
    }
    function tsOf(iso) {
      const n = Number(new Date(iso || 0));
      return isNaN(n) ? 0 : n;
    }
    function fmtPnl(n) {
      if (n == null || isNaN(Number(n))) return '—';
      const v = Number(n);
      const txt = fmtNum(v);
      const cls = v < 0 ? 'text-danger' : (v > 0 ? 'text-success' : '');
      return `<span class="${cls}">${txt}</span>`;
    }

    const rows = [];

    (paperTrades || []).forEach(t => {
      const gross = t.gross_pnl != null ? Number(t.gross_pnl) : null;
      const net = t.net_pnl != null ? Number(t.net_pnl) : (t.pnl != null ? Number(t.pnl) : null);
      rows.push({
        sort_priority: 1,
        sort_ts: Math.max(tsOf(t.exit_time), tsOf(t.entry_time)),
        time: formatTime(t.exit_time || t.entry_time),
        mode: 'PAPER',
        instrument: '—',
        symbol: t.symbol || '—',
        strategy: t.strategy || '—',
        status: '<span class="badge bg-secondary">CLOSED</span>',
        entry: fmtNum(t.entry_price),
        exit: fmtNum(t.exit_price),
        qty: t.qty != null ? t.qty : '—',
        gross: fmtPnl(gross),
        net: fmtPnl(net),
        reason: t.exit_reason || '—'
      });
    });

    (liveTrades || []).forEach(t => {
      const gross = t.gross_pnl != null ? Number(t.gross_pnl) : null;
      const net = t.net_pnl != null ? Number(t.net_pnl) : (t.pnl != null ? Number(t.pnl) : null);
      rows.push({
        sort_priority: 1,
        sort_ts: Math.max(tsOf(t.exit_time), tsOf(t.entry_time)),
        time: formatTime(t.exit_time || t.entry_time),
        mode: 'LIVE',
        instrument: '—',
        symbol: t.symbol || '—',
        strategy: t.strategy || '—',
        status: '<span class="badge bg-secondary">CLOSED</span>',
        entry: fmtNum(t.entry_price),
        exit: fmtNum(t.exit_price),
        qty: t.qty != null ? t.qty : '—',
        gross: fmtPnl(gross),
        net: fmtPnl(net),
        reason: t.exit_reason || '—'
      });
    });

    (paperOpen || []).forEach(s => {
      const t = s.current_trade || {};
      const entry = Number(t.entry_price || 0);
      const ltp = Number(s.current_ltp || entry || 0);
      const qty = Number(t.qty || 0);
      const gross = (entry > 0 && qty > 0) ? ((ltp - entry) * qty) : null;
      rows.push({
        sort_priority: 3,
        sort_ts: tsOf(t.entry_time || s.createdAt),
        time: formatTime(t.entry_time || s.createdAt),
        mode: 'PAPER',
        instrument: s.instrument || '—',
        symbol: t.symbol || s.tradingsymbol || '—',
        strategy: t.strategy_name || '—',
        status: '<span class="badge bg-warning text-dark">OPEN</span>',
        entry: fmtNum(entry),
        exit: '—',
        qty: qty || '—',
        gross: fmtPnl(gross),
        net: fmtPnl(gross),
        reason: t.exit_reason || '—'
      });
    });

    (liveOpen || []).forEach(s => {
      const t = s.current_trade || {};
      const entry = Number(t.entry_price || 0);
      const ltp = Number(s.current_ltp || entry || 0);
      const qty = Number(t.qty || 0);
      const gross = (entry > 0 && qty > 0) ? ((ltp - entry) * qty) : null;
      rows.push({
        sort_priority: 3,
        sort_ts: tsOf(t.entry_time || s.createdAt),
        time: formatTime(t.entry_time || s.createdAt),
        mode: 'LIVE',
        instrument: s.instrument || '—',
        symbol: t.symbol || s.tradingsymbol || '—',
        strategy: t.strategy_name || '—',
        status: '<span class="badge bg-warning text-dark">OPEN</span>',
        entry: fmtNum(entry),
        exit: '—',
        qty: qty || '—',
        gross: fmtPnl(gross),
        net: fmtPnl(gross),
        reason: t.exit_reason || '—'
      });
    });

    (paperWaiting || []).forEach(s => {
      rows.push({
        sort_priority: 4,
        sort_ts: tsOf(s.createdAt),
        time: formatTime(s.createdAt),
        mode: 'PAPER',
        instrument: s.instrument || '—',
        symbol: s.tradingsymbol || '—',
        strategy: ((s.recommendation || {}).strategyName) || '—',
        status: '<span class="badge bg-info text-dark">WAITING</span>',
        entry: '—',
        exit: '—',
        qty: '—',
        gross: '—',
        net: '—',
        reason: '—'
      });
    });

    (liveWaiting || []).forEach(s => {
      rows.push({
        sort_priority: 4,
        sort_ts: tsOf(s.createdAt),
        time: formatTime(s.createdAt),
        mode: 'LIVE',
        instrument: s.instrument || '—',
        symbol: s.tradingsymbol || '—',
        strategy: ((s.recommendation || {}).strategyName) || '—',
        status: '<span class="badge bg-info text-dark">WAITING</span>',
        entry: '—',
        exit: '—',
        qty: '—',
        gross: '—',
        net: '—',
        reason: '—'
      });
    });

    (brokerOrders || []).forEach(o => {
      const side = String(o.side || '').toUpperCase();
      const status = String(o.status || '').toUpperCase();
      const avg = o.average_price != null ? Number(o.average_price) : null;
      const qty = Number(o.filled_quantity || o.quantity || 0) || '—';
      const statusBadge = (status === 'COMPLETE' || Number(o.filled_quantity || 0) > 0)
        ? '<span class="badge bg-success">EXECUTED</span>'
        : '<span class="badge bg-secondary">' + esc(status || 'ORDER') + '</span>';
      rows.push({
        sort_priority: 2,
        sort_ts: tsOf(o.order_timestamp),
        time: formatTime(o.order_timestamp),
        mode: 'LIVE',
        instrument: ((String(o.symbol || '').toUpperCase().indexOf('BANK') >= 0) ? 'BANKNIFTY' : 'NIFTY'),
        symbol: o.symbol || '—',
        strategy: 'Broker Order',
        status: statusBadge,
        entry: side === 'BUY' ? fmtNum(avg) : '—',
        exit: side === 'SELL' ? fmtNum(avg) : '—',
        qty: qty,
        gross: '—',
        net: '—',
        reason: o.status_message || status || '—'
      });
    });

    rows.sort((a, b) => {
      if ((b.sort_priority || 0) !== (a.sort_priority || 0)) return (b.sort_priority || 0) - (a.sort_priority || 0);
      return (b.sort_ts || 0) - (a.sort_ts || 0);
    });

    countEl.textContent = String(rows.length);
    if (!rows.length) {
      tbody.innerHTML = '<tr><td colspan="12" class="text-center text-muted py-4">No today history.</td></tr>';
      return;
    }

    tbody.innerHTML = rows.map(r => `
      <tr>
        <td>${esc(r.time)}</td>
        <td>${esc(r.mode)}</td>
        <td>${esc(r.instrument)}</td>
        <td>${esc(r.symbol)}</td>
        <td>${esc(r.strategy)}</td>
        <td>${r.status}</td>
        <td>${r.entry}</td>
        <td>${r.exit}</td>
        <td>${esc(r.qty)}</td>
        <td>${r.gross}</td>
        <td>${r.net}</td>
        <td>${esc(r.reason)}</td>
      </tr>
    `).join('');
  }

  function updateEngineStatusUI() {
    var txt = document.getElementById('engine-status-text');
    var dot = document.getElementById('engine-dot');
    var scanEl = document.getElementById('engine-scan-countdown');
    var aiEl = document.getElementById('ai-check-countdown');
    if (txt) {
      if (engineRunning === true) txt.textContent = 'Engine: Running';
      else if (engineRunning === false) txt.textContent = 'Engine: Stopped';
      else txt.textContent = 'Engine: —';
    }
    if (dot) {
      dot.style.background = engineRunning === true ? 'var(--bs-success)' : (engineRunning === false ? '#dc3545' : 'var(--bs-secondary)');
    }
    if (scanEl) {
      const staleStatus = !lastStatusSyncMs || (Date.now() - lastStatusSyncMs > 90000);
      if (staleStatus) {
        scanEl.textContent = 'Next engine scan: —';
      } else
      if (engineNextScanSecs != null) {
        if (engineNextScanSecs < 0) {
          scanEl.innerHTML = '<span class="text-danger">Overdue: ' + Math.abs(engineNextScanSecs) + 's</span>';
        } else {
          scanEl.textContent = 'Next engine scan: ' + engineNextScanSecs + 's';
        }
      } else {
        scanEl.textContent = 'Next engine scan: —';
      }
    }
    if (aiEl) {
      const staleStatus = !lastStatusSyncMs || (Date.now() - lastStatusSyncMs > 90000);
      if (staleStatus) {
        aiEl.textContent = 'Next AI check: —';
        return;
      }
      var aiSecs = nextAiCheckDisplaySecs != null ? nextAiCheckDisplaySecs : nextAiCheckSecs;
      if (aiSecs != null) {
        if (aiSecs < 0) {
          aiEl.innerHTML = '<span class="text-danger">Next AI check: Overdue ' + Math.abs(aiSecs) + 's</span>';
      } else {
          if (aiSecs >= 60) {
            var m = Math.floor(aiSecs / 60);
            var s = aiSecs % 60;
            aiEl.textContent = 'Next AI check: ' + m + 'm ' + s + 's';
          } else {
            aiEl.textContent = 'Next AI check: ' + aiSecs + 's';
          }
        }
      } else {
        aiEl.textContent = 'Next AI check: —';
      }
    }
  }

  function statusBadge(status) {
    if (status === 'OPEN') return '<span class="badge bg-warning text-dark">OPEN</span>';
    if (status === 'Waiting to enter') return '<span class="badge bg-info text-dark">Waiting to enter</span>';
    if (status === 'Placing…') return '<span class="badge bg-info text-dark">Placing…</span>';
    return '<span class="badge bg-secondary">CLOSED</span>';
  }

  function pnlClass(pnl) {
    if (pnl == null || pnl === '') return '';
    if (typeof pnl === 'number') return pnl < 0 ? 'text-danger' : (pnl > 0 ? 'text-success' : '');
    if (typeof pnl === 'string' && pnl !== '—' && pnl.startsWith('-')) return 'text-danger';
    if (typeof pnl === 'string' && pnl !== '—' && pnl.length) return 'text-success';
    return '';
  }

  function rowToBacktest(r) {
    const statusHtml = r.status_badge || statusBadge(r.status);
    const grossClass = r.gross_pnl_class != null ? r.gross_pnl_class : pnlClass(r.gross_pnl_raw);
    const netClass = r.net_pnl_class != null ? r.net_pnl_class : pnlClass(r.net_pnl_raw);
    const cappedClass = r.risk_capped_pnl_class != null ? r.risk_capped_pnl_class : pnlClass(r.risk_capped_pnl_raw);
    const qtyCell = (r.qty_display != null && r.qty_display !== '') ? r.qty_display : r.qty;
    return `
      <tr>
        <td>${r.date}</td>
        <td>${r.ce_pe}</td>
        <td>${r.strike}</td>
        <td>${r.strategy}</td>
        <td>${r.entry_time}</td>
        <td>${r.exit_time}</td>
        <td>${r.entry_price}</td>
        <td>${r.exit_price}</td>
        <td>${r.current_price}</td>
        <td>${qtyCell}</td>
        <td>${r.price_per_lot}</td>
        <td>${r.capital_used}</td>
        <td>${r.balance_left}</td>
        <td class="${grossClass}">${r.gross_pnl}</td>
        <td>${r.charges}</td>
        <td class="${netClass}">${r.net_pnl}</td>
        <td class="${cappedClass}">${r.risk_capped_pnl}</td>
        <td>${statusHtml}</td>
        <td>${r.exit_reason}</td>
      </tr>
    `;
  }

  function buildRowsForMode(mode, closedTrades, openSessions, waitingCount, allActiveSessions, brokerOrders, livePositions) {
    const rows = [];

    function formatLots(qty, lotSize) {
      const q = Number(qty);
      const ls = Number(lotSize);
      if (!isFinite(q) || q <= 0 || !isFinite(ls) || ls <= 0) return null;
      const lots = q / ls;
      if (!isFinite(lots) || lots <= 0) return null;
      // Only render lots when quantity is a valid full-lot multiple.
      // Legacy rows may contain non-multiple qty (older paper simulator behavior).
      if (!Number.isInteger(lots)) return null;
      const lotsStr = String(lots);
      return `${lotsStr} lot${lots === 1 ? '' : 's'} (${q})`;
    }
    function toNum(v) {
      const n = Number(v);
      return isFinite(n) ? n : null;
    }
    function round2(v) {
      return Math.round((v + Number.EPSILON) * 100) / 100;
    }

    // Normalize legacy balance values per session for closed rows.
    // Some older records can be inconsistent; we derive a stable running balance
    // from net P&L when possible.
    const bySession = {};
    (closedTrades || []).forEach(t => {
      const sid = t.session_id || t.sessionId || '__NO_SESSION__';
      if (!bySession[sid]) bySession[sid] = [];
      bySession[sid].push(t);
    });
    Object.values(bySession).forEach(group => {
      group.sort((a, b) => String(a.entry_time || '').localeCompare(String(b.entry_time || '')));
      let runningBalance = null;
      group.forEach((t, idx) => {
        const net = toNum(t.net_pnl != null ? t.net_pnl : t.pnl);
        let bal = toNum(t.balance_left);
        if (idx === 0) {
          if (bal != null) runningBalance = bal;
          t._computed_balance_left = bal;
          return;
        }
        if (runningBalance != null && net != null) {
          const expected = round2(runningBalance + net);
          if (bal == null || Math.abs(bal - expected) > 1.5) {
            bal = expected;
          }
          runningBalance = bal;
          t._computed_balance_left = bal;
          return;
        }
        if (bal != null) runningBalance = bal;
        t._computed_balance_left = bal;
      });
    });
    
    // LIVE table should mirror broker "Positions" view (symbol-wise rows + day P&L).
    if (mode === 'LIVE') {
      const positions = Array.isArray(livePositions) ? livePositions : [];
      positions.forEach(p => {
        const symbol = String(p.symbol || '');
        const cepe = symbol.endsWith('CE') ? 'CE' : (symbol.endsWith('PE') ? 'PE' : '—');
        const strikeMatch = symbol.match(/(\d+)(CE|PE)$/);
        const strike = strikeMatch ? strikeMatch[1] : '—';
        const netQty = Number(p.quantity || 0) || 0;
        const buyQty = Number(p.buy_quantity || 0) || 0;
        const sellQty = Number(p.sell_quantity || 0) || 0;
        const tradedQty = Math.max(Math.abs(buyQty), Math.abs(sellQty), Math.abs(netQty));
        const pnl = Number(p.pnl || 0) || 0;
        const buyAvg = p.buy_avg_price != null ? Number(p.buy_avg_price) : null;
        const sellAvg = p.sell_avg_price != null ? Number(p.sell_avg_price) : null;
        const last = p.last_price != null ? Number(p.last_price) : null;
        rows.push({
          date: new Date().toISOString().slice(0, 10),
          ce_pe: cepe,
          strike: strike,
          strategy: 'Broker Position',
          entry_time: '—',
          exit_time: '—',
          entry_price: (buyAvg != null && buyAvg > 0) ? fmtNum(buyAvg) : '—',
          exit_price: (sellAvg != null && sellAvg > 0) ? fmtNum(sellAvg) : '—',
          current_price: (last != null && last > 0) ? fmtNum(last) : '—',
          qty: netQty !== 0 ? netQty : (tradedQty || '—'),
          qty_display: netQty !== 0 ? netQty : (tradedQty || '—'),
          price_per_lot: '—',
          capital_used: '—',
          balance_left: '—',
          gross_pnl: pnl >= 0 ? fmtNum(pnl) : '-' + fmtNum(Math.abs(pnl)),
          charges: '—',
          net_pnl: pnl >= 0 ? fmtNum(pnl) : '-' + fmtNum(Math.abs(pnl)),
          risk_capped_pnl: pnl >= 0 ? fmtNum(pnl) : '-' + fmtNum(Math.abs(pnl)),
          gross_pnl_raw: pnl,
          net_pnl_raw: pnl,
          risk_capped_pnl_raw: pnl,
          exit_reason: '—',
          status_badge: netQty !== 0
            ? '<span class="badge bg-warning text-dark">OPEN</span>'
            : '<span class="badge bg-secondary">CLOSED</span>',
          sort_priority: 2,
          sort_ts: Number(new Date())
        });
      });
      rows.sort((a, b) => Number(a.net_pnl_raw || 0) - Number(b.net_pnl_raw || 0));
      return rows;
    }

    // Add sessions waiting to enter (no current_trade yet)
    allActiveSessions.forEach(s => {
      const sessionMode = (s.execution_mode || s.mode || '').toUpperCase();
      if (sessionMode !== mode) return;
      if (s.current_trade) return; // Skip - will be handled by openSessions below
      
      const rec = s.recommendation || {};
      const recPremium = rec.premium != null ? Number(rec.premium) : null;
      const recLotSize = rec.lotSize || rec.lot_size || '—';
      const recLots = rec.positionSizeLots || rec.position_size_lots || null;
      const waitingQtyDisplay = (recLots != null && recLotSize !== '—')
        ? `${recLots} lot${Number(recLots) === 1 ? '' : 's'}`
        : String(recLotSize);
      rows.push({
        date: new Date().toISOString().split('T')[0],
        ce_pe: rec.optionType || rec.ce_pe || rec.direction || '—',
        strike: rec.strike != null ? rec.strike : '—',
        strategy: rec.strategyName || rec.strategy || '—',
        entry_time: '—',
        exit_time: '—',
        entry_price: recPremium != null && !isNaN(recPremium) ? fmtNum(recPremium) : '—',
        exit_price: '—',
        current_price: recPremium != null && !isNaN(recPremium) ? fmtNum(recPremium) : '—',
        qty: recLotSize,
        qty_display: waitingQtyDisplay,
        price_per_lot: '—',
        capital_used: '—',
        balance_left: s.virtual_balance != null ? fmtNum(s.virtual_balance) : '—',
        gross_pnl: '—',
        charges: '—',
        net_pnl: '—',
        risk_capped_pnl: '—',
        gross_pnl_raw: null,
        net_pnl_raw: null,
        risk_capped_pnl_raw: null,
        exit_reason: '—',
        status_badge: '<span class="badge bg-info text-dark">Waiting to enter</span>',
        sort_priority: 3,
        sort_ts: Number(new Date(s.createdAt || Date.now()))
      });
    });
    
    // Add open trades
    openSessions.forEach(s => {
      const t = s.current_trade;
      if (!t) return;
      
      const rec = s.recommendation || {};
      const entryPrice = t.entry_price;
      const qty = t.qty;
      const lotSize = s.lot_size || rec.lot_size || rec.lotSize || 25;
      const lotsDisplay = formatLots(qty, lotSize);
      const currentLtp = (s.current_ltp != null && s.current_ltp > 0) ? s.current_ltp : entryPrice;
      const side = (t.side || 'BUY').toUpperCase();
      
      let grossPnl = null;
      if (entryPrice != null && currentLtp != null && qty != null) {
        if (side === 'BUY') grossPnl = (currentLtp - entryPrice) * qty;
        else grossPnl = (entryPrice - currentLtp) * qty;
      }
      const maxLossPerTrade = Number(s.max_loss_per_trade != null ? s.max_loss_per_trade : (s.risk_amount_per_trade != null ? s.risk_amount_per_trade : 300));
      const normalizedMaxLoss = isNaN(maxLossPerTrade) ? 300 : Math.min(300, Math.max(1, maxLossPerTrade));
      const riskCappedOpenPnl = grossPnl != null ? Math.max(grossPnl, -normalizedMaxLoss) : null;
      
      rows.push({
        date: String(t.entry_time || '').slice(0, 10),
        ce_pe: rec.optionType || (rec.tradeType === 'CALL' ? 'CE' : 'PE') || '—',
        strike: rec.strike != null ? rec.strike : '—',
        strategy: t.strategy_name || rec.strategyName || '—',
        entry_time: formatTime(t.entry_time),
        exit_time: '—',
        entry_price: entryPrice != null ? fmtNum(entryPrice) : '—',
        exit_price: '—',
        current_price: currentLtp != null ? fmtNum(currentLtp) : '—',
        qty: qty || 0,
        qty_display: lotsDisplay || (qty || 0),
        price_per_lot: entryPrice != null && lotSize ? fmtNum(entryPrice * lotSize) : '—',
        capital_used: entryPrice != null && qty ? fmtNum(entryPrice * qty) : '—',
        balance_left: s.virtual_balance != null ? fmtNum(s.virtual_balance) : '—',
        gross_pnl: grossPnl != null ? (grossPnl >= 0 ? fmtNum(grossPnl) : '-' + fmtNum(Math.abs(grossPnl))) : '—',
        charges: '—',
        net_pnl: grossPnl != null ? (grossPnl >= 0 ? fmtNum(grossPnl) : '-' + fmtNum(Math.abs(grossPnl))) : '—',
        risk_capped_pnl: riskCappedOpenPnl != null ? (riskCappedOpenPnl >= 0 ? fmtNum(riskCappedOpenPnl) : '-' + fmtNum(Math.abs(riskCappedOpenPnl))) : '—',
        gross_pnl_raw: grossPnl,
        net_pnl_raw: grossPnl,
        risk_capped_pnl_raw: riskCappedOpenPnl,
        exit_reason: '—',
        status_badge: '<span class="badge bg-warning text-dark">OPEN</span>',
        sort_priority: 2,
        sort_ts: Number(new Date(t.entry_time || s.createdAt || Date.now()))
      });
    });
    
    // Add closed trades
    closedTrades.forEach(t => {
      const entryPrice = t.entry_price;
      const exitPrice = t.exit_price;
      const qty = t.qty || 0;
      const charges = t.charges != null ? Number(t.charges) : null;
      const netPnl = t.net_pnl != null ? Number(t.net_pnl) : (t.pnl != null ? Number(t.pnl) : null);
      const riskCappedPnl = t.risk_capped_pnl != null ? Number(t.risk_capped_pnl) : netPnl;
      let grossPnl = t.gross_pnl != null ? Number(t.gross_pnl) : null;
      // Backward compatibility: older records may have gross_pnl copied from net pnl.
      if (grossPnl == null && netPnl != null && charges != null) {
        grossPnl = netPnl + charges;
      } else if (
        grossPnl != null && netPnl != null && charges != null &&
        Math.abs(grossPnl - netPnl) < 0.01 && Math.abs(charges) > 0.01
      ) {
        grossPnl = netPnl + charges;
      }
      const parsedLotSize = t.lot_size != null ? Number(t.lot_size) : null;
      const inferredLotSize = (!parsedLotSize && qty)
        ? ((Number(qty) % 25 === 0) ? 25 : ((Number(qty) % 15 === 0) ? 15 : null))
        : null;
      const lotSize = parsedLotSize || inferredLotSize;
      const lotsDisplay = formatLots(qty, lotSize);
      const pricePerLot = t.price_per_lot != null
        ? Number(t.price_per_lot)
        : ((entryPrice != null && lotSize) ? (Number(entryPrice) * lotSize) : null);
      const capitalUsed = t.capital_used != null
        ? Number(t.capital_used)
        : ((entryPrice != null && qty != null) ? (Number(entryPrice) * Number(qty)) : null);
      rows.push({
        date: formatDate(t.entry_time),
        ce_pe: t.option_type || '—',
        strike: t.strike != null ? t.strike : '—',
        strategy: t.strategy || '—',
        entry_time: formatTime(t.entry_time),
        exit_time: formatTime(t.exit_time),
        entry_price: fmtNum(entryPrice),
        exit_price: fmtNum(exitPrice),
        current_price: '—',
        qty: qty,
        qty_display: lotsDisplay || qty,
        price_per_lot: pricePerLot != null && !isNaN(pricePerLot) ? fmtNum(pricePerLot) : '—',
        capital_used: capitalUsed != null && !isNaN(capitalUsed) ? fmtNum(capitalUsed) : '—',
        balance_left: t._computed_balance_left != null ? fmtNum(t._computed_balance_left) : (t.balance_left != null ? fmtNum(t.balance_left) : '—'),
        gross_pnl: grossPnl != null ? (grossPnl >= 0 ? fmtNum(grossPnl) : '-' + fmtNum(Math.abs(grossPnl))) : '—',
        charges: charges != null ? fmtNum(charges) : '—',
        net_pnl: netPnl != null ? (netPnl >= 0 ? fmtNum(netPnl) : '-' + fmtNum(Math.abs(netPnl))) : '—',
        risk_capped_pnl: riskCappedPnl != null ? (riskCappedPnl >= 0 ? fmtNum(riskCappedPnl) : '-' + fmtNum(Math.abs(riskCappedPnl))) : '—',
        gross_pnl_raw: grossPnl,
        net_pnl_raw: netPnl,
        risk_capped_pnl_raw: riskCappedPnl,
        exit_reason: t.exit_reason || '—',
        status_badge: '<span class="badge bg-secondary">CLOSED</span>',
        sort_priority: 1,
        sort_ts: Number(new Date(t.entry_time || t.exit_time || Date.now()))
      });
    });
    
    rows.sort((a, b) => {
      const aPriority = Number(a.sort_priority || 0);
      const bPriority = Number(b.sort_priority || 0);
      if (bPriority !== aPriority) return bPriority - aPriority;
      const aTs = Number(a.sort_ts || 0);
      const bTs = Number(b.sort_ts || 0);
      return bTs - aTs;
    });
    return rows;
  }

  function renderModeExecutions(mode, closedTrades, openSessions, waitingCount, activeSessions, brokerOrders, livePositions) {
    const isPaper = mode === 'PAPER';
    const tbody = document.getElementById(isPaper ? 'paper-executions-tbody' : 'live-executions-tbody');
    const countEl = document.getElementById(isPaper ? 'paper-executions-count' : 'live-executions-count');
    const waitingEl = document.getElementById(isPaper ? 'paper-sessions-waiting-msg' : 'live-sessions-waiting-msg');
    const prefix = isPaper ? 'Paper' : 'Live';
    if (waitingEl) {
      if (isPaper) {
        waitingEl.style.display = waitingCount > 0 ? 'block' : 'none';
        waitingEl.textContent = waitingCount + ' ' + prefix.toLowerCase() + ' session(s) active — engine will place trade when conditions are met.';
      } else {
        waitingEl.style.display = 'none';
      }
    }
    const rows = buildRowsForMode(mode, closedTrades, openSessions, waitingCount, activeSessions, brokerOrders, livePositions);
    if (isPaper) {
      activePaperSessionId = (activeSessions.length > 0 && (activeSessions[0].sessionId || activeSessions[0].session_id)) || null;
      const stopBtn = document.getElementById('paper-stop-btn');
      if (stopBtn) stopBtn.style.display = activePaperSessionId ? '' : 'none';
    } else {
      activeLiveSessionId = (activeSessions.length > 0 && (activeSessions[0].sessionId || activeSessions[0].session_id)) || null;
      const stopBtn = document.getElementById('live-stop-btn');
      if (stopBtn) stopBtn.style.display = activeLiveSessionId ? '' : 'none';
    }
    countEl.textContent = rows.length;
    if (!isPaper) {
      const pnlEl = document.getElementById('live-positions-total-pnl');
      if (pnlEl) {
        const total = (Array.isArray(livePositions) ? livePositions : []).reduce((acc, p) => {
          const n = Number((p || {}).pnl);
          return acc + (isNaN(n) ? 0 : n);
        }, 0);
        pnlEl.textContent = 'Total P&L ' + fmtNum(total);
        pnlEl.classList.remove('text-success', 'text-danger', 'text-light');
        pnlEl.classList.add(total < 0 ? 'text-danger' : (total > 0 ? 'text-success' : 'text-light'));
      }
    }
    if (rows.length === 0) {
      tbody.innerHTML = '<tr><td colspan="20" class="text-center text-muted py-4">No ' + prefix.toLowerCase() + ' trades today.</td></tr>';
      return;
    }
    tbody.innerHTML = rows.map(rowToBacktest).join('');
  }

  function startCountdown() {
    if (countdownTimer) clearInterval(countdownTimer);
    dataRefreshSecs = 60;
    function tick() {
      if (dataRefreshSecs > 0) dataRefreshSecs--; else { runRefresh(); }
      
      if (typeof engineNextScanSecs === 'number') {
        engineNextScanSecs--;
        // Trigger refresh when we exactly hit 0 to sync with expected engine tick
        if (engineNextScanSecs === 0) runRefresh();
      }
      
      if (typeof nextAiCheckSecs === 'number' && nextAiCheckSecs > 0) nextAiCheckSecs--;
      if (typeof nextAiCheckDisplaySecs === 'number') {
        nextAiCheckDisplaySecs--;
        if (nextAiCheckDisplaySecs < 0) nextAiCheckDisplaySecs = 60;
      } else if (nextAiCheckSecs != null && nextAiCheckSecs >= 0) {
        nextAiCheckDisplaySecs = nextAiCheckSecs;
      }
      updateEngineStatusUI();
    }
    tick();
    countdownTimer = setInterval(tick, 1000);
  }

  document.getElementById('investment-amount').addEventListener('input', fetchRiskConfig);
  document.getElementById('investment-amount').addEventListener('change', fetchRiskConfig);
  document.getElementById('paper-risk-amount').addEventListener('input', fetchRiskConfig);
  document.getElementById('paper-risk-amount').addEventListener('change', fetchRiskConfig);

  document.getElementById('paper-enable-ai-switching').addEventListener('change', function() {
    var strategySelect = document.getElementById('paper-strategy');
    strategySelect.disabled = this.checked;
    if (this.checked) strategySelect.value = 'AI_AUTO';
  });

  function stopSession(sessionId, statusElId, label, btn) {
    if (!sessionId) return;
    if (btn) btn.disabled = true;
    fetch('/api/trade-sessions/' + encodeURIComponent(sessionId) + '/kill', { method: 'POST' })
      .then(r => r.json())
      .then(data => {
        const el = document.getElementById(statusElId);
        if (el) el.innerHTML = data.ok ? '<span class="text-success">' + label + ' stopped.</span>' : '<span class="text-danger">' + (data.error || 'Failed to stop') + '</span>';
        if (data.ok) runRefresh();
      })
      .catch(() => {
        const el = document.getElementById(statusElId);
        if (el) el.innerHTML = '<span class="text-danger">Request failed</span>';
      })
      .finally(() => { if (btn) btn.disabled = false; });
  }

  function resetCooldownFromBadge(btn) {
    const sessionId = (btn && btn.dataset && btn.dataset.sessionId) ? btn.dataset.sessionId : null;
    if (!sessionId) return;
    btn.style.pointerEvents = 'none';
    fetch('/api/trade-sessions/' + encodeURIComponent(sessionId) + '/cooldown-reset', { method: 'POST' })
      .then(r => r.json())
      .then(data => {
        const el = document.getElementById('paper-trade-status');
        if (el) {
          if (data && data.ok) el.innerHTML = '<span class="text-success">Cooldown reset successfully.</span>';
          else el.innerHTML = '<span class="text-danger">' + ((data && data.error) || 'Failed to reset cooldown') + '</span>';
        }
        runRefresh();
      })
      .catch(() => {
        const el = document.getElementById('paper-trade-status');
        if (el) el.innerHTML = '<span class="text-danger">Cooldown reset request failed</span>';
      })
      .finally(() => { btn.style.pointerEvents = ''; });
  }

  document.getElementById('paper-stop-btn').addEventListener('click', function() {
    stopSession(activePaperSessionId, 'paper-trade-status', 'Paper', this);
  });
  document.getElementById('live-stop-btn').addEventListener('click', function() {
    stopSession(activeLiveSessionId, 'paper-trade-status', 'Live', this);
  });
  document.getElementById('cooldown-active-badge').addEventListener('click', function() {
    resetCooldownFromBadge(this);
  });

  document.getElementById('paper-trade-btn').addEventListener('click', function() {
    const btn = this;
    const status = document.getElementById('paper-trade-status');
    const instrument = document.getElementById('paper-instrument').value;
    const investmentAmount = parseFloat(document.getElementById('investment-amount').value) || 10000;
    const riskAmount = parseFloat(document.getElementById('paper-risk-amount').value) || 300;
    const dailyLossLimit = parseFloat(document.getElementById('paper-daily-loss-limit').value) || 3000;
    const mode = getTradeMode();
    const isLive = mode === 'LIVE';
    const today = new Date().toISOString().slice(0, 10);
    btn.disabled = true;
    status.innerHTML = '<span class="text-primary">Starting session...</span>';
    const aiEnabled = document.getElementById('paper-enable-ai-switching') && document.getElementById('paper-enable-ai-switching').checked;
    const apiUrl = isLive ? '/api/live-trade/execute' : '/api/paper-trade/execute';
    fetch(apiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        instrument: instrument,
        investment_amount: investmentAmount,
        risk_amount_per_trade: riskAmount,
        daily_loss_limit: dailyLossLimit,
        ai_auto_switching_enabled: aiEnabled
      })
    })
      .then(r => r.json())
      .then(data => {
        if (data.ok) {
          status.innerHTML = '<span class="text-success">' + (data.message || 'Session started.') + '</span>';
          var rec = data.recommendation || {};
          var premium = rec.premium != null ? Number(rec.premium) : null;
          var lotSize = rec.lot_size != null ? Number(rec.lot_size) : 25;
          var balance = data.virtual_balance != null ? Number(data.virtual_balance) : null;
          var now = new Date();
          var timeStr = now.toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
          var dateStr = now.toISOString().slice(0, 10);
          optimisticRows.push({
            mode: mode,
            date: dateStr,
            ce_pe: rec.optionType || '—',
            strike: rec.strike != null ? rec.strike : '—',
            strategy: rec.strategyName || '—',
            entry_time: timeStr,
            entry_price: premium != null ? fmtNum(premium) : '—',
            price_per_lot: premium != null && lotSize ? fmtNum(premium * lotSize) : '—',
            qty: '—',
            capital_used: '—',
            balance_left: balance != null ? fmtNum(balance) : '—',
            exit_reason: '—',
            status: 'Waiting to enter'
          });
          fetchExecutions();
        } else {
          status.innerHTML = '<span class="text-danger">' + (data.error || 'Failed') + '</span>';
        }
      })
      .catch(err => {
        status.innerHTML = '<span class="text-danger">Request failed</span>';
        fetchExecutions();
      })
      .finally(() => { btn.disabled = false; });
  });

  document.getElementById('money-mode').addEventListener('change', function() {
    fetchExecutions();
  });

  fetchRiskConfig();
  fetchBalance();
  fetchEngineStatus();
  fetchExecutions();
  setInterval(fetchEngineStatus, 15000);
  startCountdown();
})();
</script>
{% endblock %}
